// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_ingress_policy_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func IngressPolicyListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"classifier": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"entries": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"dot1p_policy_entry": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"direct_to_pfc_queue": schema.BoolAttribute{
																Optional:            true,
																Description:         "In addition to creating a Dot1p PCP value to Forwarding Class mapping, this will map the PCP values directly to the PFC queue specified in the Forwarding Class to Queue mapping.",
																MarkdownDescription: "In addition to creating a Dot1p PCP value to Forwarding Class mapping, this will map the PCP values directly to the PFC queue specified in the Forwarding Class to Queue mapping.",
															},
															"drop_probability_level": schema.StringAttribute{
																Optional:            true,
																Description:         "Assign matching packets to the specified drop probability level.",
																MarkdownDescription: "Assign matching packets to the specified drop probability level.",
															},
															"forwarding_class": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to a ForwardingClass resource to which the value is mapped.",
																MarkdownDescription: "Reference to a ForwardingClass resource to which the value is mapped.",
															},
															"pcp_values": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"range_end": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Optional end of PCP range (inclusive) which would start from the Value to the RangeEnd.",
																			MarkdownDescription: "Optional end of PCP range (inclusive) which would start from the Value to the RangeEnd.",
																		},
																		"value": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Single PCP value or start of range.",
																			MarkdownDescription: "Single PCP value or start of range.",
																		},
																	},
																	CustomType: PcpValuesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: PcpValuesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "List of PCP values or ranges used to match packets to classify into Forwarding Classes.",
																MarkdownDescription: "List of PCP values or ranges used to match packets to classify into Forwarding Classes.",
															},
														},
														CustomType: Dot1pPolicyEntryType{
															ObjectType: types.ObjectType{
																AttrTypes: Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "A Dot1p policy entry - only a single Dot1p entry is allowed per classifier resource.",
														MarkdownDescription: "A Dot1p policy entry - only a single Dot1p entry is allowed per classifier resource.",
													},
													"dscp_policy_entry": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"drop_probability_level": schema.StringAttribute{
																Optional:            true,
																Description:         "Assign matching packets to the specified drop probability level.",
																MarkdownDescription: "Assign matching packets to the specified drop probability level.",
															},
															"dscp_values": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"range_end": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Optional end of DSCP range (inclusive) which would start from the Value to the RangeEnd.",
																			MarkdownDescription: "Optional end of DSCP range (inclusive) which would start from the Value to the RangeEnd.",
																		},
																		"value": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Single DSCP value or start of range.",
																			MarkdownDescription: "Single DSCP value or start of range.",
																		},
																	},
																	CustomType: DscpValuesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: DscpValuesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "List of DSCP values or ranges used to match packets to classify into Forwarding Classes.",
																MarkdownDescription: "List of DSCP values or ranges used to match packets to classify into Forwarding Classes.",
															},
															"forwarding_class": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to a ForwardingClass resource to which the value is mapped.",
																MarkdownDescription: "Reference to a ForwardingClass resource to which the value is mapped.",
															},
														},
														CustomType: DscpPolicyEntryType{
															ObjectType: types.ObjectType{
																AttrTypes: DscpPolicyEntryValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "A DSCP policy entry - only a single DSCP entry is allowed per classifier resource.",
														MarkdownDescription: "A DSCP policy entry - only a single DSCP entry is allowed per classifier resource.",
													},
													"ip_entry": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"action": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"drop_probability_level": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Assign matching packets to the specified drop probability level.",
																		MarkdownDescription: "Assign matching packets to the specified drop probability level.",
																	},
																	"dscp_rewrite_value": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Rewrite actions associated with packets that match the classifier entry.",
																		MarkdownDescription: "Rewrite actions associated with packets that match the classifier entry.",
																	},
																	"forwarding_class": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Reference to a ForwardingClass resource to which the value is mapped.",
																		MarkdownDescription: "Reference to a ForwardingClass resource to which the value is mapped.",
																	},
																},
																CustomType: ActionType{
																	ObjectType: types.ObjectType{
																		AttrTypes: ActionValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "An action to take on the matched packets.",
																MarkdownDescription: "An action to take on the matched packets.",
															},
															"destination_port_name": schema.StringAttribute{
																Optional:            true,
																Description:         "Destination port to match by name.",
																MarkdownDescription: "Destination port to match by name.",
															},
															"destination_port_number": schema.Int64Attribute{
																Optional:            true,
																Description:         "Destination port to match by numerical value.",
																MarkdownDescription: "Destination port to match by numerical value.",
															},
															"destination_port_operator": schema.StringAttribute{
																Optional:            true,
																Description:         "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
																MarkdownDescription: "Operator to use when matching destinationPort, either Equals, GreaterOrEquals, or LessOrEquals.",
															},
															"destination_port_range": schema.StringAttribute{
																Optional:            true,
																Description:         "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
																MarkdownDescription: "Range of destination ports to match, in the format n-m, e.g. 100-200,  The start and end of the range must be port numbers.",
															},
															"destination_prefix": schema.StringAttribute{
																Optional:            true,
																Description:         "Destination prefix to match.",
																MarkdownDescription: "Destination prefix to match.",
															},
															"first_fragment": schema.BoolAttribute{
																Optional:            true,
																Description:         "Match the first fragment only.",
																MarkdownDescription: "Match the first fragment only.",
															},
															"fragment": schema.BoolAttribute{
																Optional:            true,
																Description:         "Match any fragment.",
																MarkdownDescription: "Match any fragment.",
															},
															"icmp_code": schema.ListAttribute{
																ElementType:         types.Int64Type,
																Optional:            true,
																Description:         "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
																MarkdownDescription: "Match a specific ICMP code, as a number between 0-255, e.g. 0.",
															},
															"icmp_type_name": schema.StringAttribute{
																Optional:            true,
																Description:         "Match a specific ICMP type by name, e.g. dest-unreachable.",
																MarkdownDescription: "Match a specific ICMP type by name, e.g. dest-unreachable.",
															},
															"icmp_type_number": schema.Int64Attribute{
																Optional:            true,
																Description:         "Match a specific ICMP type by number.",
																MarkdownDescription: "Match a specific ICMP type by number.",
															},
															"protocol_name": schema.StringAttribute{
																Optional:            true,
																Description:         "Match a specific IP protocol name (specified in the type field of the IP header).",
																MarkdownDescription: "Match a specific IP protocol name (specified in the type field of the IP header).",
															},
															"protocol_number": schema.Int64Attribute{
																Optional:            true,
																Description:         "Match a specific IP protocol number (specified in the type field of the IP header).",
																MarkdownDescription: "Match a specific IP protocol number (specified in the type field of the IP header).",
															},
															"source_port_name": schema.StringAttribute{
																Optional:            true,
																Description:         "Source port to match by name.",
																MarkdownDescription: "Source port to match by name.",
															},
															"source_port_number": schema.Int64Attribute{
																Optional:            true,
																Description:         "Source port to match by numerical value.",
																MarkdownDescription: "Source port to match by numerical value.",
															},
															"source_port_operator": schema.StringAttribute{
																Optional:            true,
																Description:         "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
																MarkdownDescription: "Operator to use when matching sourcePort, either Equals, GreaterOrEquals, or LessOrEquals.",
															},
															"source_port_range": schema.StringAttribute{
																Optional:            true,
																Description:         "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
																MarkdownDescription: "Range of source ports to match, in the format n-m, e.g. 100-200.  The start and end of the range must be port numbers.",
															},
															"source_prefix": schema.StringAttribute{
																Optional:            true,
																Description:         "Source prefix to match.",
																MarkdownDescription: "Source prefix to match.",
															},
															"tcp_flags": schema.StringAttribute{
																Optional:            true,
																Description:         "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
																MarkdownDescription: "Match TCP flags, usable with !, &, | and the flags RST, SYN, and ACK.",
															},
														},
														CustomType: IpEntryType{
															ObjectType: types.ObjectType{
																AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "An IPv4 or IPv6 multifield classifier entry.",
														MarkdownDescription: "An IPv4 or IPv6 multifield classifier entry.",
													},
													"type": schema.StringAttribute{
														Optional:            true,
														Description:         "Type of the entry which can be IPV4, IPV6, Dot1pPolicy, DSCPPolicy, or Auto.",
														MarkdownDescription: "Type of the entry which can be IPV4, IPV6, Dot1pPolicy, DSCPPolicy, or Auto.",
													},
												},
												CustomType: EntriesType{
													ObjectType: types.ObjectType{
														AttrTypes: EntriesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "Specifies the list of filter entries, in order.\nA classifier containing multiple entry types may result in multiple classifiers being created on the target node.\nIPV4 and IPV6 entries will create multifield classifier policies.",
											MarkdownDescription: "Specifies the list of filter entries, in order.\nA classifier containing multiple entry types may result in multiple classifiers being created on the target node.\nIPV4 and IPV6 entries will create multifield classifier policies.",
										},
									},
									CustomType: ClassifierType{
										ObjectType: types.ObjectType{
											AttrTypes: ClassifierValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Classifier manages the configuration of traffic classification policies in a network. It includes various entry types like IPv4, IPv6, Dot1p, and DSCP policies. Each entry specifies how traffic should be classified and what actions should be taken on the matched packets.",
									MarkdownDescription: "Classifier manages the configuration of traffic classification policies in a network. It includes various entry types like IPv4, IPv6, Dot1p, and DSCP policies. Each entry specifies how traffic should be classified and what actions should be taken on the matched packets.",
								},
								"forwarding_class_to_queue_mapping": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"forwarding_classes": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Description:         "The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
												MarkdownDescription: "The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
											},
											"queue": schema.StringAttribute{
												Optional:            true,
												Description:         "The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
												MarkdownDescription: "The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
											},
										},
										CustomType: ForwardingClassToQueueMappingType{
											ObjectType: types.ObjectType{
												AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Forwarding class to queue mapping policy.",
									MarkdownDescription: "Forwarding class to queue mapping policy.",
								},
								"policers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"committed_burst_size": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum CIR bucket depth in bytes.",
												MarkdownDescription: "Maximum CIR bucket depth in bytes.",
											},
											"committed_rate": schema.Int64Attribute{
												Optional:            true,
												Description:         "The committed information rate (CIR) of the policer, defined in kilobits (1024 bits) per second.",
												MarkdownDescription: "The committed information rate (CIR) of the policer, defined in kilobits (1024 bits) per second.",
											},
											"committed_rate_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "The committed information rate (CIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
												MarkdownDescription: "The committed information rate (CIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
											},
											"exceed_action": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"drop_probability_level": schema.StringAttribute{
														Optional: true,
													},
												},
												CustomType: ExceedActionType{
													ObjectType: types.ObjectType{
														AttrTypes: ExceedActionValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Applies a drop-probability to packets that the policer has determined are exceeding (yellow).",
												MarkdownDescription: "Applies a drop-probability to packets that the policer has determined are exceeding (yellow).",
											},
											"forwarding_classes": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"forwarding_classes": schema.ListAttribute{
															ElementType:         types.StringType,
															Optional:            true,
															Description:         "The forwarding class of the packets on which to apply the Policer.  To match all traffic set this to 'ALL'.",
															MarkdownDescription: "The forwarding class of the packets on which to apply the Policer.  To match all traffic set this to 'ALL'.",
														},
														"forwarding_types": schema.ListAttribute{
															ElementType: types.StringType,
															Optional:    true,
														},
													},
													CustomType: ForwardingClassesType{
														ObjectType: types.ObjectType{
															AttrTypes: ForwardingClassesValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional:            true,
												Description:         "The list of forwarding classes with traffic to be sent to the policer.  Unless specified all traffic is matched for this policer.",
												MarkdownDescription: "The list of forwarding classes with traffic to be sent to the policer.  Unless specified all traffic is matched for this policer.",
											},
											"maximum_burst_size": schema.Int64Attribute{
												Optional:            true,
												Description:         "Maximum PIR bucket depth in bytes.",
												MarkdownDescription: "Maximum PIR bucket depth in bytes.",
											},
											"min_interface_speed": schema.Int64Attribute{
												Optional:            true,
												Description:         "Minimum interface speed (kbps) to calculate PeakRate and CommittedRate for devices where configuration is not supported in percentage.",
												MarkdownDescription: "Minimum interface speed (kbps) to calculate PeakRate and CommittedRate for devices where configuration is not supported in percentage.",
											},
											"peak_rate": schema.Int64Attribute{
												Optional:            true,
												Description:         "The peak information rate (PIR) of the policer, defined in kilobits (1024 bits) per second.",
												MarkdownDescription: "The peak information rate (PIR) of the policer, defined in kilobits (1024 bits) per second.",
											},
											"peak_rate_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "The peak information rate (PIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
												MarkdownDescription: "The peak information rate (PIR) of the policer, defined as a percentage of the Interface speed on which it is applied.",
											},
											"violate_action": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"drop_probability_level": schema.StringAttribute{
														Optional: true,
													},
												},
												CustomType: ViolateActionType{
													ObjectType: types.ObjectType{
														AttrTypes: ViolateActionValue{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Applies a drop-probability to packets that the policer has determined are exceeding (red).",
												MarkdownDescription: "Applies a drop-probability to packets that the policer has determined are exceeding (red).",
											},
										},
										CustomType: PolicersType{
											ObjectType: types.ObjectType{
												AttrTypes: PolicersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Ordered list of policers where the first policer is evaluated first before proceeding to the next.",
									MarkdownDescription: "Ordered list of policers where the first policer is evaluated first before proceeding to the next.",
								},
								"queue_management": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"pfc_reserved_buffer_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "Percentage of the linecard buffer reserved for accomodating incoming traffic while upstream node reacts to generated PFC-pause frames. Note: this percentage must be common across all EgressPolicies and QueuesSets used on the same linecard.",
												MarkdownDescription: "Percentage of the linecard buffer reserved for accomodating incoming traffic while upstream node reacts to generated PFC-pause frames. Note: this percentage must be common across all EgressPolicies and QueuesSets used on the same linecard.",
											},
											"queues": schema.ListNestedAttribute{
												NestedObject: schema.NestedAttributeObject{
													Attributes: map[string]schema.Attribute{
														"committed_burst_size": schema.Int64Attribute{
															Optional:            true,
															Description:         "Committed Burst Size.",
															MarkdownDescription: "Committed Burst Size.",
														},
														"maximum_burst_size": schema.Int64Attribute{
															Optional:            true,
															Description:         "Maximum amount of shared buffer memory available to the queue in bytes.",
															MarkdownDescription: "Maximum amount of shared buffer memory available to the queue in bytes.",
														},
														"pfc_off_threshold": schema.Int64Attribute{
															Optional:            true,
															Description:         "PFC off threshold.",
															MarkdownDescription: "PFC off threshold.",
														},
														"pfc_on_threshold": schema.Int64Attribute{
															Optional:            true,
															Description:         "PFC on threshold.",
															MarkdownDescription: "PFC on threshold.",
														},
														"pfc_pause_frame_priority": schema.Int64Attribute{
															Optional:            true,
															Description:         "PFC priorities indicated in generated pfc-pause-frame if congestion occurs in a given pfc-queue.",
															MarkdownDescription: "PFC priorities indicated in generated pfc-pause-frame if congestion occurs in a given pfc-queue.",
														},
														"pfc_reserved_share_buffer_percent": schema.Int64Attribute{
															Optional:            true,
															Description:         "Maximum level the pfc-queue can take from pfc-reserved buffer configured per given forwarding-complex.",
															MarkdownDescription: "Maximum level the pfc-queue can take from pfc-reserved buffer configured per given forwarding-complex.",
														},
														"queue": schema.StringAttribute{
															Optional:            true,
															Description:         "Reference to a Queue resource.",
															MarkdownDescription: "Reference to a Queue resource.",
														},
													},
													CustomType: QueuesType{
														ObjectType: types.ObjectType{
															AttrTypes: QueuesValue{}.AttributeTypes(ctx),
														},
													},
												},
												Optional:            true,
												Description:         "List of queues.",
												MarkdownDescription: "List of queues.",
											},
										},
										CustomType: QueueManagementType{
											ObjectType: types.ObjectType{
												AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Queue management policy for egress queues.",
									MarkdownDescription: "Queue management policy for egress queues.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "IngressPolicySpec defines the desired state of IngressPolicy",
							MarkdownDescription: "IngressPolicySpec defines the desired state of IngressPolicy",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "IngressPolicyStatus defines the observed state of IngressPolicy",
							MarkdownDescription: "IngressPolicyStatus defines the observed state of IngressPolicy",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type IngressPolicyListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	classifierAttribute, ok := attributes["classifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classifier is missing from object`)

		return nil, diags
	}

	classifierVal, ok := classifierAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classifier expected to be basetypes.ObjectValue, was: %T`, classifierAttribute))
	}

	forwardingClassToQueueMappingAttribute, ok := attributes["forwarding_class_to_queue_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class_to_queue_mapping is missing from object`)

		return nil, diags
	}

	forwardingClassToQueueMappingVal, ok := forwardingClassToQueueMappingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class_to_queue_mapping expected to be basetypes.ListValue, was: %T`, forwardingClassToQueueMappingAttribute))
	}

	policersAttribute, ok := attributes["policers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policers is missing from object`)

		return nil, diags
	}

	policersVal, ok := policersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policers expected to be basetypes.ListValue, was: %T`, policersAttribute))
	}

	queueManagementAttribute, ok := attributes["queue_management"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_management is missing from object`)

		return nil, diags
	}

	queueManagementVal, ok := queueManagementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_management expected to be basetypes.ListValue, was: %T`, queueManagementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Classifier:                    classifierVal,
		ForwardingClassToQueueMapping: forwardingClassToQueueMappingVal,
		Policers:                      policersVal,
		QueueManagement:               queueManagementVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	classifierAttribute, ok := attributes["classifier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`classifier is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	classifierVal, ok := classifierAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`classifier expected to be basetypes.ObjectValue, was: %T`, classifierAttribute))
	}

	forwardingClassToQueueMappingAttribute, ok := attributes["forwarding_class_to_queue_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class_to_queue_mapping is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	forwardingClassToQueueMappingVal, ok := forwardingClassToQueueMappingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class_to_queue_mapping expected to be basetypes.ListValue, was: %T`, forwardingClassToQueueMappingAttribute))
	}

	policersAttribute, ok := attributes["policers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	policersVal, ok := policersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policers expected to be basetypes.ListValue, was: %T`, policersAttribute))
	}

	queueManagementAttribute, ok := attributes["queue_management"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_management is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	queueManagementVal, ok := queueManagementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_management expected to be basetypes.ListValue, was: %T`, queueManagementAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Classifier:                    classifierVal,
		ForwardingClassToQueueMapping: forwardingClassToQueueMappingVal,
		Policers:                      policersVal,
		QueueManagement:               queueManagementVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Classifier                    basetypes.ObjectValue `tfsdk:"classifier"`
	ForwardingClassToQueueMapping basetypes.ListValue   `tfsdk:"forwarding_class_to_queue_mapping"`
	Policers                      basetypes.ListValue   `tfsdk:"policers"`
	QueueManagement               basetypes.ListValue   `tfsdk:"queue_management"`
	state                         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["classifier"] = basetypes.ObjectType{
		AttrTypes: ClassifierValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["forwarding_class_to_queue_mapping"] = basetypes.ListType{
		ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["policers"] = basetypes.ListType{
		ElemType: PolicersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["queue_management"] = basetypes.ListType{
		ElemType: QueueManagementValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Classifier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["classifier"] = val

		val, err = v.ForwardingClassToQueueMapping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_class_to_queue_mapping"] = val

		val, err = v.Policers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policers"] = val

		val, err = v.QueueManagement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue_management"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var classifier basetypes.ObjectValue

	if v.Classifier.IsNull() {
		classifier = types.ObjectNull(
			ClassifierValue{}.AttributeTypes(ctx),
		)
	}

	if v.Classifier.IsUnknown() {
		classifier = types.ObjectUnknown(
			ClassifierValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Classifier.IsNull() && !v.Classifier.IsUnknown() {
		classifier = types.ObjectValueMust(
			ClassifierValue{}.AttributeTypes(ctx),
			v.Classifier.Attributes(),
		)
	}

	forwardingClassToQueueMapping := types.ListValueMust(
		ForwardingClassToQueueMappingType{
			basetypes.ObjectType{
				AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
			},
		},
		v.ForwardingClassToQueueMapping.Elements(),
	)

	if v.ForwardingClassToQueueMapping.IsNull() {
		forwardingClassToQueueMapping = types.ListNull(
			ForwardingClassToQueueMappingType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ForwardingClassToQueueMapping.IsUnknown() {
		forwardingClassToQueueMapping = types.ListUnknown(
			ForwardingClassToQueueMappingType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	policers := types.ListValueMust(
		PolicersType{
			basetypes.ObjectType{
				AttrTypes: PolicersValue{}.AttributeTypes(ctx),
			},
		},
		v.Policers.Elements(),
	)

	if v.Policers.IsNull() {
		policers = types.ListNull(
			PolicersType{
				basetypes.ObjectType{
					AttrTypes: PolicersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Policers.IsUnknown() {
		policers = types.ListUnknown(
			PolicersType{
				basetypes.ObjectType{
					AttrTypes: PolicersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	queueManagement := types.ListValueMust(
		QueueManagementType{
			basetypes.ObjectType{
				AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
			},
		},
		v.QueueManagement.Elements(),
	)

	if v.QueueManagement.IsNull() {
		queueManagement = types.ListNull(
			QueueManagementType{
				basetypes.ObjectType{
					AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.QueueManagement.IsUnknown() {
		queueManagement = types.ListUnknown(
			QueueManagementType{
				basetypes.ObjectType{
					AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"classifier": basetypes.ObjectType{
			AttrTypes: ClassifierValue{}.AttributeTypes(ctx),
		},
		"forwarding_class_to_queue_mapping": basetypes.ListType{
			ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
		},
		"policers": basetypes.ListType{
			ElemType: PolicersValue{}.Type(ctx),
		},
		"queue_management": basetypes.ListType{
			ElemType: QueueManagementValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"classifier":                        classifier,
			"forwarding_class_to_queue_mapping": forwardingClassToQueueMapping,
			"policers":                          policers,
			"queue_management":                  queueManagement,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Classifier.Equal(other.Classifier) {
		return false
	}

	if !v.ForwardingClassToQueueMapping.Equal(other.ForwardingClassToQueueMapping) {
		return false
	}

	if !v.Policers.Equal(other.Policers) {
		return false
	}

	if !v.QueueManagement.Equal(other.QueueManagement) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"classifier": basetypes.ObjectType{
			AttrTypes: ClassifierValue{}.AttributeTypes(ctx),
		},
		"forwarding_class_to_queue_mapping": basetypes.ListType{
			ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
		},
		"policers": basetypes.ListType{
			ElemType: PolicersValue{}.Type(ctx),
		},
		"queue_management": basetypes.ListType{
			ElemType: QueueManagementValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ClassifierType{}

type ClassifierType struct {
	basetypes.ObjectType
}

func (t ClassifierType) Equal(o attr.Type) bool {
	other, ok := o.(ClassifierType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ClassifierType) String() string {
	return "ClassifierType"
}

func (t ClassifierType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return nil, diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ClassifierValue{
		Entries: entriesVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewClassifierValueNull() ClassifierValue {
	return ClassifierValue{
		state: attr.ValueStateNull,
	}
}

func NewClassifierValueUnknown() ClassifierValue {
	return ClassifierValue{
		state: attr.ValueStateUnknown,
	}
}

func NewClassifierValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ClassifierValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ClassifierValue Attribute Value",
				"While creating a ClassifierValue value, a missing attribute value was detected. "+
					"A ClassifierValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClassifierValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ClassifierValue Attribute Type",
				"While creating a ClassifierValue value, an invalid attribute value was detected. "+
					"A ClassifierValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ClassifierValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ClassifierValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ClassifierValue Attribute Value",
				"While creating a ClassifierValue value, an extra attribute value was detected. "+
					"A ClassifierValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ClassifierValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewClassifierValueUnknown(), diags
	}

	entriesAttribute, ok := attributes["entries"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`entries is missing from object`)

		return NewClassifierValueUnknown(), diags
	}

	entriesVal, ok := entriesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`entries expected to be basetypes.ListValue, was: %T`, entriesAttribute))
	}

	if diags.HasError() {
		return NewClassifierValueUnknown(), diags
	}

	return ClassifierValue{
		Entries: entriesVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewClassifierValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ClassifierValue {
	object, diags := NewClassifierValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewClassifierValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ClassifierType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewClassifierValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewClassifierValueUnknown(), nil
	}

	if in.IsNull() {
		return NewClassifierValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewClassifierValueMust(ClassifierValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ClassifierType) ValueType(ctx context.Context) attr.Value {
	return ClassifierValue{}
}

var _ basetypes.ObjectValuable = ClassifierValue{}

type ClassifierValue struct {
	Entries basetypes.ListValue `tfsdk:"entries"`
	state   attr.ValueState
}

func (v ClassifierValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["entries"] = basetypes.ListType{
		ElemType: EntriesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Entries.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["entries"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ClassifierValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ClassifierValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ClassifierValue) String() string {
	return "ClassifierValue"
}

func (v ClassifierValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	entries := types.ListValueMust(
		EntriesType{
			basetypes.ObjectType{
				AttrTypes: EntriesValue{}.AttributeTypes(ctx),
			},
		},
		v.Entries.Elements(),
	)

	if v.Entries.IsNull() {
		entries = types.ListNull(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Entries.IsUnknown() {
		entries = types.ListUnknown(
			EntriesType{
				basetypes.ObjectType{
					AttrTypes: EntriesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"entries": entries,
		})

	return objVal, diags
}

func (v ClassifierValue) Equal(o attr.Value) bool {
	other, ok := o.(ClassifierValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Entries.Equal(other.Entries) {
		return false
	}

	return true
}

func (v ClassifierValue) Type(ctx context.Context) attr.Type {
	return ClassifierType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ClassifierValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"entries": basetypes.ListType{
			ElemType: EntriesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = EntriesType{}

type EntriesType struct {
	basetypes.ObjectType
}

func (t EntriesType) Equal(o attr.Type) bool {
	other, ok := o.(EntriesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EntriesType) String() string {
	return "EntriesType"
}

func (t EntriesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dot1pPolicyEntryAttribute, ok := attributes["dot1p_policy_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_policy_entry is missing from object`)

		return nil, diags
	}

	dot1pPolicyEntryVal, ok := dot1pPolicyEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_policy_entry expected to be basetypes.ObjectValue, was: %T`, dot1pPolicyEntryAttribute))
	}

	dscpPolicyEntryAttribute, ok := attributes["dscp_policy_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_policy_entry is missing from object`)

		return nil, diags
	}

	dscpPolicyEntryVal, ok := dscpPolicyEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_policy_entry expected to be basetypes.ObjectValue, was: %T`, dscpPolicyEntryAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return nil, diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EntriesValue{
		Dot1pPolicyEntry: dot1pPolicyEntryVal,
		DscpPolicyEntry:  dscpPolicyEntryVal,
		IpEntry:          ipEntryVal,
		EntriesType:      typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueNull() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateNull,
	}
}

func NewEntriesValueUnknown() EntriesValue {
	return EntriesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEntriesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EntriesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EntriesValue Attribute Value",
				"While creating a EntriesValue value, a missing attribute value was detected. "+
					"A EntriesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EntriesValue Attribute Type",
				"While creating a EntriesValue value, an invalid attribute value was detected. "+
					"A EntriesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EntriesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EntriesValue Attribute Value",
				"While creating a EntriesValue value, an extra attribute value was detected. "+
					"A EntriesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EntriesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	dot1pPolicyEntryAttribute, ok := attributes["dot1p_policy_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_policy_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	dot1pPolicyEntryVal, ok := dot1pPolicyEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_policy_entry expected to be basetypes.ObjectValue, was: %T`, dot1pPolicyEntryAttribute))
	}

	dscpPolicyEntryAttribute, ok := attributes["dscp_policy_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_policy_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	dscpPolicyEntryVal, ok := dscpPolicyEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_policy_entry expected to be basetypes.ObjectValue, was: %T`, dscpPolicyEntryAttribute))
	}

	ipEntryAttribute, ok := attributes["ip_entry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_entry is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	ipEntryVal, ok := ipEntryAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_entry expected to be basetypes.ObjectValue, was: %T`, ipEntryAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewEntriesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewEntriesValueUnknown(), diags
	}

	return EntriesValue{
		Dot1pPolicyEntry: dot1pPolicyEntryVal,
		DscpPolicyEntry:  dscpPolicyEntryVal,
		IpEntry:          ipEntryVal,
		EntriesType:      typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewEntriesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EntriesValue {
	object, diags := NewEntriesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEntriesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EntriesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEntriesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEntriesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEntriesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEntriesValueMust(EntriesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EntriesType) ValueType(ctx context.Context) attr.Value {
	return EntriesValue{}
}

var _ basetypes.ObjectValuable = EntriesValue{}

type EntriesValue struct {
	Dot1pPolicyEntry basetypes.ObjectValue `tfsdk:"dot1p_policy_entry"`
	DscpPolicyEntry  basetypes.ObjectValue `tfsdk:"dscp_policy_entry"`
	IpEntry          basetypes.ObjectValue `tfsdk:"ip_entry"`
	EntriesType      basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v EntriesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["dot1p_policy_entry"] = basetypes.ObjectType{
		AttrTypes: Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dscp_policy_entry"] = basetypes.ObjectType{
		AttrTypes: DscpPolicyEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_entry"] = basetypes.ObjectType{
		AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Dot1pPolicyEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dot1p_policy_entry"] = val

		val, err = v.DscpPolicyEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp_policy_entry"] = val

		val, err = v.IpEntry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_entry"] = val

		val, err = v.EntriesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EntriesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EntriesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EntriesValue) String() string {
	return "EntriesValue"
}

func (v EntriesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dot1pPolicyEntry basetypes.ObjectValue

	if v.Dot1pPolicyEntry.IsNull() {
		dot1pPolicyEntry = types.ObjectNull(
			Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.Dot1pPolicyEntry.IsUnknown() {
		dot1pPolicyEntry = types.ObjectUnknown(
			Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Dot1pPolicyEntry.IsNull() && !v.Dot1pPolicyEntry.IsUnknown() {
		dot1pPolicyEntry = types.ObjectValueMust(
			Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
			v.Dot1pPolicyEntry.Attributes(),
		)
	}

	var dscpPolicyEntry basetypes.ObjectValue

	if v.DscpPolicyEntry.IsNull() {
		dscpPolicyEntry = types.ObjectNull(
			DscpPolicyEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.DscpPolicyEntry.IsUnknown() {
		dscpPolicyEntry = types.ObjectUnknown(
			DscpPolicyEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DscpPolicyEntry.IsNull() && !v.DscpPolicyEntry.IsUnknown() {
		dscpPolicyEntry = types.ObjectValueMust(
			DscpPolicyEntryValue{}.AttributeTypes(ctx),
			v.DscpPolicyEntry.Attributes(),
		)
	}

	var ipEntry basetypes.ObjectValue

	if v.IpEntry.IsNull() {
		ipEntry = types.ObjectNull(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectUnknown(
			IpEntryValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpEntry.IsNull() && !v.IpEntry.IsUnknown() {
		ipEntry = types.ObjectValueMust(
			IpEntryValue{}.AttributeTypes(ctx),
			v.IpEntry.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dot1p_policy_entry": basetypes.ObjectType{
			AttrTypes: Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
		},
		"dscp_policy_entry": basetypes.ObjectType{
			AttrTypes: DscpPolicyEntryValue{}.AttributeTypes(ctx),
		},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dot1p_policy_entry": dot1pPolicyEntry,
			"dscp_policy_entry":  dscpPolicyEntry,
			"ip_entry":           ipEntry,
			"type":               v.EntriesType,
		})

	return objVal, diags
}

func (v EntriesValue) Equal(o attr.Value) bool {
	other, ok := o.(EntriesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dot1pPolicyEntry.Equal(other.Dot1pPolicyEntry) {
		return false
	}

	if !v.DscpPolicyEntry.Equal(other.DscpPolicyEntry) {
		return false
	}

	if !v.IpEntry.Equal(other.IpEntry) {
		return false
	}

	if !v.EntriesType.Equal(other.EntriesType) {
		return false
	}

	return true
}

func (v EntriesValue) Type(ctx context.Context) attr.Type {
	return EntriesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EntriesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dot1p_policy_entry": basetypes.ObjectType{
			AttrTypes: Dot1pPolicyEntryValue{}.AttributeTypes(ctx),
		},
		"dscp_policy_entry": basetypes.ObjectType{
			AttrTypes: DscpPolicyEntryValue{}.AttributeTypes(ctx),
		},
		"ip_entry": basetypes.ObjectType{
			AttrTypes: IpEntryValue{}.AttributeTypes(ctx),
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Dot1pPolicyEntryType{}

type Dot1pPolicyEntryType struct {
	basetypes.ObjectType
}

func (t Dot1pPolicyEntryType) Equal(o attr.Type) bool {
	other, ok := o.(Dot1pPolicyEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Dot1pPolicyEntryType) String() string {
	return "Dot1pPolicyEntryType"
}

func (t Dot1pPolicyEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directToPfcQueueAttribute, ok := attributes["direct_to_pfc_queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direct_to_pfc_queue is missing from object`)

		return nil, diags
	}

	directToPfcQueueVal, ok := directToPfcQueueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direct_to_pfc_queue expected to be basetypes.BoolValue, was: %T`, directToPfcQueueAttribute))
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return nil, diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return nil, diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	pcpValuesAttribute, ok := attributes["pcp_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_values is missing from object`)

		return nil, diags
	}

	pcpValuesVal, ok := pcpValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_values expected to be basetypes.ListValue, was: %T`, pcpValuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Dot1pPolicyEntryValue{
		DirectToPfcQueue:     directToPfcQueueVal,
		DropProbabilityLevel: dropProbabilityLevelVal,
		ForwardingClass:      forwardingClassVal,
		PcpValues:            pcpValuesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDot1pPolicyEntryValueNull() Dot1pPolicyEntryValue {
	return Dot1pPolicyEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewDot1pPolicyEntryValueUnknown() Dot1pPolicyEntryValue {
	return Dot1pPolicyEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDot1pPolicyEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Dot1pPolicyEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Dot1pPolicyEntryValue Attribute Value",
				"While creating a Dot1pPolicyEntryValue value, a missing attribute value was detected. "+
					"A Dot1pPolicyEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pPolicyEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Dot1pPolicyEntryValue Attribute Type",
				"While creating a Dot1pPolicyEntryValue value, an invalid attribute value was detected. "+
					"A Dot1pPolicyEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pPolicyEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Dot1pPolicyEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Dot1pPolicyEntryValue Attribute Value",
				"While creating a Dot1pPolicyEntryValue value, an extra attribute value was detected. "+
					"A Dot1pPolicyEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Dot1pPolicyEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	directToPfcQueueAttribute, ok := attributes["direct_to_pfc_queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direct_to_pfc_queue is missing from object`)

		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	directToPfcQueueVal, ok := directToPfcQueueAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direct_to_pfc_queue expected to be basetypes.BoolValue, was: %T`, directToPfcQueueAttribute))
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	pcpValuesAttribute, ok := attributes["pcp_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_values is missing from object`)

		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	pcpValuesVal, ok := pcpValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_values expected to be basetypes.ListValue, was: %T`, pcpValuesAttribute))
	}

	if diags.HasError() {
		return NewDot1pPolicyEntryValueUnknown(), diags
	}

	return Dot1pPolicyEntryValue{
		DirectToPfcQueue:     directToPfcQueueVal,
		DropProbabilityLevel: dropProbabilityLevelVal,
		ForwardingClass:      forwardingClassVal,
		PcpValues:            pcpValuesVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDot1pPolicyEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Dot1pPolicyEntryValue {
	object, diags := NewDot1pPolicyEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDot1pPolicyEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Dot1pPolicyEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDot1pPolicyEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDot1pPolicyEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDot1pPolicyEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDot1pPolicyEntryValueMust(Dot1pPolicyEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Dot1pPolicyEntryType) ValueType(ctx context.Context) attr.Value {
	return Dot1pPolicyEntryValue{}
}

var _ basetypes.ObjectValuable = Dot1pPolicyEntryValue{}

type Dot1pPolicyEntryValue struct {
	DirectToPfcQueue     basetypes.BoolValue   `tfsdk:"direct_to_pfc_queue"`
	DropProbabilityLevel basetypes.StringValue `tfsdk:"drop_probability_level"`
	ForwardingClass      basetypes.StringValue `tfsdk:"forwarding_class"`
	PcpValues            basetypes.ListValue   `tfsdk:"pcp_values"`
	state                attr.ValueState
}

func (v Dot1pPolicyEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["direct_to_pfc_queue"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["drop_probability_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["forwarding_class"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pcp_values"] = basetypes.ListType{
		ElemType: PcpValuesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.DirectToPfcQueue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direct_to_pfc_queue"] = val

		val, err = v.DropProbabilityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_level"] = val

		val, err = v.ForwardingClass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_class"] = val

		val, err = v.PcpValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pcp_values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Dot1pPolicyEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Dot1pPolicyEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Dot1pPolicyEntryValue) String() string {
	return "Dot1pPolicyEntryValue"
}

func (v Dot1pPolicyEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	pcpValues := types.ListValueMust(
		PcpValuesType{
			basetypes.ObjectType{
				AttrTypes: PcpValuesValue{}.AttributeTypes(ctx),
			},
		},
		v.PcpValues.Elements(),
	)

	if v.PcpValues.IsNull() {
		pcpValues = types.ListNull(
			PcpValuesType{
				basetypes.ObjectType{
					AttrTypes: PcpValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PcpValues.IsUnknown() {
		pcpValues = types.ListUnknown(
			PcpValuesType{
				basetypes.ObjectType{
					AttrTypes: PcpValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"direct_to_pfc_queue":    basetypes.BoolType{},
		"drop_probability_level": basetypes.StringType{},
		"forwarding_class":       basetypes.StringType{},
		"pcp_values": basetypes.ListType{
			ElemType: PcpValuesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"direct_to_pfc_queue":    v.DirectToPfcQueue,
			"drop_probability_level": v.DropProbabilityLevel,
			"forwarding_class":       v.ForwardingClass,
			"pcp_values":             pcpValues,
		})

	return objVal, diags
}

func (v Dot1pPolicyEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(Dot1pPolicyEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DirectToPfcQueue.Equal(other.DirectToPfcQueue) {
		return false
	}

	if !v.DropProbabilityLevel.Equal(other.DropProbabilityLevel) {
		return false
	}

	if !v.ForwardingClass.Equal(other.ForwardingClass) {
		return false
	}

	if !v.PcpValues.Equal(other.PcpValues) {
		return false
	}

	return true
}

func (v Dot1pPolicyEntryValue) Type(ctx context.Context) attr.Type {
	return Dot1pPolicyEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Dot1pPolicyEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"direct_to_pfc_queue":    basetypes.BoolType{},
		"drop_probability_level": basetypes.StringType{},
		"forwarding_class":       basetypes.StringType{},
		"pcp_values": basetypes.ListType{
			ElemType: PcpValuesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PcpValuesType{}

type PcpValuesType struct {
	basetypes.ObjectType
}

func (t PcpValuesType) Equal(o attr.Type) bool {
	other, ok := o.(PcpValuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PcpValuesType) String() string {
	return "PcpValuesType"
}

func (t PcpValuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	rangeEndAttribute, ok := attributes["range_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range_end is missing from object`)

		return nil, diags
	}

	rangeEndVal, ok := rangeEndAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range_end expected to be basetypes.Int64Value, was: %T`, rangeEndAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PcpValuesValue{
		RangeEnd: rangeEndVal,
		Value:    valueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPcpValuesValueNull() PcpValuesValue {
	return PcpValuesValue{
		state: attr.ValueStateNull,
	}
}

func NewPcpValuesValueUnknown() PcpValuesValue {
	return PcpValuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPcpValuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PcpValuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PcpValuesValue Attribute Value",
				"While creating a PcpValuesValue value, a missing attribute value was detected. "+
					"A PcpValuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcpValuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PcpValuesValue Attribute Type",
				"While creating a PcpValuesValue value, an invalid attribute value was detected. "+
					"A PcpValuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PcpValuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PcpValuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PcpValuesValue Attribute Value",
				"While creating a PcpValuesValue value, an extra attribute value was detected. "+
					"A PcpValuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PcpValuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPcpValuesValueUnknown(), diags
	}

	rangeEndAttribute, ok := attributes["range_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range_end is missing from object`)

		return NewPcpValuesValueUnknown(), diags
	}

	rangeEndVal, ok := rangeEndAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range_end expected to be basetypes.Int64Value, was: %T`, rangeEndAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewPcpValuesValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewPcpValuesValueUnknown(), diags
	}

	return PcpValuesValue{
		RangeEnd: rangeEndVal,
		Value:    valueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewPcpValuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PcpValuesValue {
	object, diags := NewPcpValuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPcpValuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PcpValuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPcpValuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPcpValuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPcpValuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPcpValuesValueMust(PcpValuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PcpValuesType) ValueType(ctx context.Context) attr.Value {
	return PcpValuesValue{}
}

var _ basetypes.ObjectValuable = PcpValuesValue{}

type PcpValuesValue struct {
	RangeEnd basetypes.Int64Value `tfsdk:"range_end"`
	Value    basetypes.Int64Value `tfsdk:"value"`
	state    attr.ValueState
}

func (v PcpValuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["range_end"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.RangeEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["range_end"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PcpValuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PcpValuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PcpValuesValue) String() string {
	return "PcpValuesValue"
}

func (v PcpValuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"range_end": basetypes.Int64Type{},
		"value":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"range_end": v.RangeEnd,
			"value":     v.Value,
		})

	return objVal, diags
}

func (v PcpValuesValue) Equal(o attr.Value) bool {
	other, ok := o.(PcpValuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RangeEnd.Equal(other.RangeEnd) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v PcpValuesValue) Type(ctx context.Context) attr.Type {
	return PcpValuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PcpValuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"range_end": basetypes.Int64Type{},
		"value":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DscpPolicyEntryType{}

type DscpPolicyEntryType struct {
	basetypes.ObjectType
}

func (t DscpPolicyEntryType) Equal(o attr.Type) bool {
	other, ok := o.(DscpPolicyEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DscpPolicyEntryType) String() string {
	return "DscpPolicyEntryType"
}

func (t DscpPolicyEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return nil, diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	dscpValuesAttribute, ok := attributes["dscp_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_values is missing from object`)

		return nil, diags
	}

	dscpValuesVal, ok := dscpValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_values expected to be basetypes.ListValue, was: %T`, dscpValuesAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return nil, diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DscpPolicyEntryValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		DscpValues:           dscpValuesVal,
		ForwardingClass:      forwardingClassVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDscpPolicyEntryValueNull() DscpPolicyEntryValue {
	return DscpPolicyEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewDscpPolicyEntryValueUnknown() DscpPolicyEntryValue {
	return DscpPolicyEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDscpPolicyEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DscpPolicyEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DscpPolicyEntryValue Attribute Value",
				"While creating a DscpPolicyEntryValue value, a missing attribute value was detected. "+
					"A DscpPolicyEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpPolicyEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DscpPolicyEntryValue Attribute Type",
				"While creating a DscpPolicyEntryValue value, an invalid attribute value was detected. "+
					"A DscpPolicyEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpPolicyEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DscpPolicyEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DscpPolicyEntryValue Attribute Value",
				"While creating a DscpPolicyEntryValue value, an extra attribute value was detected. "+
					"A DscpPolicyEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DscpPolicyEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDscpPolicyEntryValueUnknown(), diags
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return NewDscpPolicyEntryValueUnknown(), diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	dscpValuesAttribute, ok := attributes["dscp_values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_values is missing from object`)

		return NewDscpPolicyEntryValueUnknown(), diags
	}

	dscpValuesVal, ok := dscpValuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_values expected to be basetypes.ListValue, was: %T`, dscpValuesAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return NewDscpPolicyEntryValueUnknown(), diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	if diags.HasError() {
		return NewDscpPolicyEntryValueUnknown(), diags
	}

	return DscpPolicyEntryValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		DscpValues:           dscpValuesVal,
		ForwardingClass:      forwardingClassVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewDscpPolicyEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DscpPolicyEntryValue {
	object, diags := NewDscpPolicyEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDscpPolicyEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DscpPolicyEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDscpPolicyEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDscpPolicyEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDscpPolicyEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDscpPolicyEntryValueMust(DscpPolicyEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DscpPolicyEntryType) ValueType(ctx context.Context) attr.Value {
	return DscpPolicyEntryValue{}
}

var _ basetypes.ObjectValuable = DscpPolicyEntryValue{}

type DscpPolicyEntryValue struct {
	DropProbabilityLevel basetypes.StringValue `tfsdk:"drop_probability_level"`
	DscpValues           basetypes.ListValue   `tfsdk:"dscp_values"`
	ForwardingClass      basetypes.StringValue `tfsdk:"forwarding_class"`
	state                attr.ValueState
}

func (v DscpPolicyEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dscp_values"] = basetypes.ListType{
		ElemType: DscpValuesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["forwarding_class"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DropProbabilityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_level"] = val

		val, err = v.DscpValues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp_values"] = val

		val, err = v.ForwardingClass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_class"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DscpPolicyEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DscpPolicyEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DscpPolicyEntryValue) String() string {
	return "DscpPolicyEntryValue"
}

func (v DscpPolicyEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dscpValues := types.ListValueMust(
		DscpValuesType{
			basetypes.ObjectType{
				AttrTypes: DscpValuesValue{}.AttributeTypes(ctx),
			},
		},
		v.DscpValues.Elements(),
	)

	if v.DscpValues.IsNull() {
		dscpValues = types.ListNull(
			DscpValuesType{
				basetypes.ObjectType{
					AttrTypes: DscpValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DscpValues.IsUnknown() {
		dscpValues = types.ListUnknown(
			DscpValuesType{
				basetypes.ObjectType{
					AttrTypes: DscpValuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
		"dscp_values": basetypes.ListType{
			ElemType: DscpValuesValue{}.Type(ctx),
		},
		"forwarding_class": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability_level": v.DropProbabilityLevel,
			"dscp_values":            dscpValues,
			"forwarding_class":       v.ForwardingClass,
		})

	return objVal, diags
}

func (v DscpPolicyEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(DscpPolicyEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbabilityLevel.Equal(other.DropProbabilityLevel) {
		return false
	}

	if !v.DscpValues.Equal(other.DscpValues) {
		return false
	}

	if !v.ForwardingClass.Equal(other.ForwardingClass) {
		return false
	}

	return true
}

func (v DscpPolicyEntryValue) Type(ctx context.Context) attr.Type {
	return DscpPolicyEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DscpPolicyEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
		"dscp_values": basetypes.ListType{
			ElemType: DscpValuesValue{}.Type(ctx),
		},
		"forwarding_class": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = DscpValuesType{}

type DscpValuesType struct {
	basetypes.ObjectType
}

func (t DscpValuesType) Equal(o attr.Type) bool {
	other, ok := o.(DscpValuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DscpValuesType) String() string {
	return "DscpValuesType"
}

func (t DscpValuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	rangeEndAttribute, ok := attributes["range_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range_end is missing from object`)

		return nil, diags
	}

	rangeEndVal, ok := rangeEndAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range_end expected to be basetypes.Int64Value, was: %T`, rangeEndAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DscpValuesValue{
		RangeEnd: rangeEndVal,
		Value:    valueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDscpValuesValueNull() DscpValuesValue {
	return DscpValuesValue{
		state: attr.ValueStateNull,
	}
}

func NewDscpValuesValueUnknown() DscpValuesValue {
	return DscpValuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDscpValuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DscpValuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DscpValuesValue Attribute Value",
				"While creating a DscpValuesValue value, a missing attribute value was detected. "+
					"A DscpValuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpValuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DscpValuesValue Attribute Type",
				"While creating a DscpValuesValue value, an invalid attribute value was detected. "+
					"A DscpValuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpValuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DscpValuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DscpValuesValue Attribute Value",
				"While creating a DscpValuesValue value, an extra attribute value was detected. "+
					"A DscpValuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DscpValuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDscpValuesValueUnknown(), diags
	}

	rangeEndAttribute, ok := attributes["range_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`range_end is missing from object`)

		return NewDscpValuesValueUnknown(), diags
	}

	rangeEndVal, ok := rangeEndAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`range_end expected to be basetypes.Int64Value, was: %T`, rangeEndAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewDscpValuesValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.Int64Value, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewDscpValuesValueUnknown(), diags
	}

	return DscpValuesValue{
		RangeEnd: rangeEndVal,
		Value:    valueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDscpValuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DscpValuesValue {
	object, diags := NewDscpValuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDscpValuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DscpValuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDscpValuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDscpValuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDscpValuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDscpValuesValueMust(DscpValuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DscpValuesType) ValueType(ctx context.Context) attr.Value {
	return DscpValuesValue{}
}

var _ basetypes.ObjectValuable = DscpValuesValue{}

type DscpValuesValue struct {
	RangeEnd basetypes.Int64Value `tfsdk:"range_end"`
	Value    basetypes.Int64Value `tfsdk:"value"`
	state    attr.ValueState
}

func (v DscpValuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["range_end"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.RangeEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["range_end"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DscpValuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DscpValuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DscpValuesValue) String() string {
	return "DscpValuesValue"
}

func (v DscpValuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"range_end": basetypes.Int64Type{},
		"value":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"range_end": v.RangeEnd,
			"value":     v.Value,
		})

	return objVal, diags
}

func (v DscpValuesValue) Equal(o attr.Value) bool {
	other, ok := o.(DscpValuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.RangeEnd.Equal(other.RangeEnd) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v DscpValuesValue) Type(ctx context.Context) attr.Type {
	return DscpValuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DscpValuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"range_end": basetypes.Int64Type{},
		"value":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpEntryType{}

type IpEntryType struct {
	basetypes.ObjectType
}

func (t IpEntryType) Equal(o attr.Type) bool {
	other, ok := o.(IpEntryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpEntryType) String() string {
	return "IpEntryType"
}

func (t IpEntryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return nil, diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return nil, diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return nil, diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return nil, diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return nil, diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return nil, diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return nil, diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return nil, diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return nil, diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return nil, diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return nil, diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return nil, diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return nil, diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return nil, diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return nil, diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return nil, diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return nil, diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return nil, diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueNull() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateNull,
	}
}

func NewIpEntryValueUnknown() IpEntryValue {
	return IpEntryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpEntryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpEntryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, a missing attribute value was detected. "+
					"A IpEntryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpEntryValue Attribute Type",
				"While creating a IpEntryValue value, an invalid attribute value was detected. "+
					"A IpEntryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpEntryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpEntryValue Attribute Value",
				"While creating a IpEntryValue value, an extra attribute value was detected. "+
					"A IpEntryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpEntryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	destinationPortNameAttribute, ok := attributes["destination_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNameVal, ok := destinationPortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_name expected to be basetypes.StringValue, was: %T`, destinationPortNameAttribute))
	}

	destinationPortNumberAttribute, ok := attributes["destination_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortNumberVal, ok := destinationPortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_number expected to be basetypes.Int64Value, was: %T`, destinationPortNumberAttribute))
	}

	destinationPortOperatorAttribute, ok := attributes["destination_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortOperatorVal, ok := destinationPortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_operator expected to be basetypes.StringValue, was: %T`, destinationPortOperatorAttribute))
	}

	destinationPortRangeAttribute, ok := attributes["destination_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPortRangeVal, ok := destinationPortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_port_range expected to be basetypes.StringValue, was: %T`, destinationPortRangeAttribute))
	}

	destinationPrefixAttribute, ok := attributes["destination_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	destinationPrefixVal, ok := destinationPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination_prefix expected to be basetypes.StringValue, was: %T`, destinationPrefixAttribute))
	}

	firstFragmentAttribute, ok := attributes["first_fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`first_fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	firstFragmentVal, ok := firstFragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`first_fragment expected to be basetypes.BoolValue, was: %T`, firstFragmentAttribute))
	}

	fragmentAttribute, ok := attributes["fragment"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fragment is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	fragmentVal, ok := fragmentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fragment expected to be basetypes.BoolValue, was: %T`, fragmentAttribute))
	}

	icmpCodeAttribute, ok := attributes["icmp_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_code is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpCodeVal, ok := icmpCodeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_code expected to be basetypes.ListValue, was: %T`, icmpCodeAttribute))
	}

	icmpTypeNameAttribute, ok := attributes["icmp_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNameVal, ok := icmpTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_name expected to be basetypes.StringValue, was: %T`, icmpTypeNameAttribute))
	}

	icmpTypeNumberAttribute, ok := attributes["icmp_type_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`icmp_type_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	icmpTypeNumberVal, ok := icmpTypeNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`icmp_type_number expected to be basetypes.Int64Value, was: %T`, icmpTypeNumberAttribute))
	}

	protocolNameAttribute, ok := attributes["protocol_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNameVal, ok := protocolNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_name expected to be basetypes.StringValue, was: %T`, protocolNameAttribute))
	}

	protocolNumberAttribute, ok := attributes["protocol_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	protocolNumberVal, ok := protocolNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol_number expected to be basetypes.Int64Value, was: %T`, protocolNumberAttribute))
	}

	sourcePortNameAttribute, ok := attributes["source_port_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_name is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNameVal, ok := sourcePortNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_name expected to be basetypes.StringValue, was: %T`, sourcePortNameAttribute))
	}

	sourcePortNumberAttribute, ok := attributes["source_port_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_number is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortNumberVal, ok := sourcePortNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_number expected to be basetypes.Int64Value, was: %T`, sourcePortNumberAttribute))
	}

	sourcePortOperatorAttribute, ok := attributes["source_port_operator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_operator is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortOperatorVal, ok := sourcePortOperatorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_operator expected to be basetypes.StringValue, was: %T`, sourcePortOperatorAttribute))
	}

	sourcePortRangeAttribute, ok := attributes["source_port_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_port_range is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePortRangeVal, ok := sourcePortRangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_port_range expected to be basetypes.StringValue, was: %T`, sourcePortRangeAttribute))
	}

	sourcePrefixAttribute, ok := attributes["source_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_prefix is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	sourcePrefixVal, ok := sourcePrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_prefix expected to be basetypes.StringValue, was: %T`, sourcePrefixAttribute))
	}

	tcpFlagsAttribute, ok := attributes["tcp_flags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tcp_flags is missing from object`)

		return NewIpEntryValueUnknown(), diags
	}

	tcpFlagsVal, ok := tcpFlagsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tcp_flags expected to be basetypes.StringValue, was: %T`, tcpFlagsAttribute))
	}

	if diags.HasError() {
		return NewIpEntryValueUnknown(), diags
	}

	return IpEntryValue{
		Action:                  actionVal,
		DestinationPortName:     destinationPortNameVal,
		DestinationPortNumber:   destinationPortNumberVal,
		DestinationPortOperator: destinationPortOperatorVal,
		DestinationPortRange:    destinationPortRangeVal,
		DestinationPrefix:       destinationPrefixVal,
		FirstFragment:           firstFragmentVal,
		Fragment:                fragmentVal,
		IcmpCode:                icmpCodeVal,
		IcmpTypeName:            icmpTypeNameVal,
		IcmpTypeNumber:          icmpTypeNumberVal,
		ProtocolName:            protocolNameVal,
		ProtocolNumber:          protocolNumberVal,
		SourcePortName:          sourcePortNameVal,
		SourcePortNumber:        sourcePortNumberVal,
		SourcePortOperator:      sourcePortOperatorVal,
		SourcePortRange:         sourcePortRangeVal,
		SourcePrefix:            sourcePrefixVal,
		TcpFlags:                tcpFlagsVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewIpEntryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpEntryValue {
	object, diags := NewIpEntryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpEntryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpEntryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpEntryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpEntryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpEntryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpEntryValueMust(IpEntryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpEntryType) ValueType(ctx context.Context) attr.Value {
	return IpEntryValue{}
}

var _ basetypes.ObjectValuable = IpEntryValue{}

type IpEntryValue struct {
	Action                  basetypes.ObjectValue `tfsdk:"action"`
	DestinationPortName     basetypes.StringValue `tfsdk:"destination_port_name"`
	DestinationPortNumber   basetypes.Int64Value  `tfsdk:"destination_port_number"`
	DestinationPortOperator basetypes.StringValue `tfsdk:"destination_port_operator"`
	DestinationPortRange    basetypes.StringValue `tfsdk:"destination_port_range"`
	DestinationPrefix       basetypes.StringValue `tfsdk:"destination_prefix"`
	FirstFragment           basetypes.BoolValue   `tfsdk:"first_fragment"`
	Fragment                basetypes.BoolValue   `tfsdk:"fragment"`
	IcmpCode                basetypes.ListValue   `tfsdk:"icmp_code"`
	IcmpTypeName            basetypes.StringValue `tfsdk:"icmp_type_name"`
	IcmpTypeNumber          basetypes.Int64Value  `tfsdk:"icmp_type_number"`
	ProtocolName            basetypes.StringValue `tfsdk:"protocol_name"`
	ProtocolNumber          basetypes.Int64Value  `tfsdk:"protocol_number"`
	SourcePortName          basetypes.StringValue `tfsdk:"source_port_name"`
	SourcePortNumber        basetypes.Int64Value  `tfsdk:"source_port_number"`
	SourcePortOperator      basetypes.StringValue `tfsdk:"source_port_operator"`
	SourcePortRange         basetypes.StringValue `tfsdk:"source_port_range"`
	SourcePrefix            basetypes.StringValue `tfsdk:"source_prefix"`
	TcpFlags                basetypes.StringValue `tfsdk:"tcp_flags"`
	state                   attr.ValueState
}

func (v IpEntryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 19)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.ObjectType{
		AttrTypes: ActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["destination_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["destination_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["destination_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["first_fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["fragment"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["icmp_code"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["icmp_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["icmp_type_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["protocol_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["source_port_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["source_port_operator"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_port_range"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["source_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tcp_flags"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 19)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.DestinationPortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_name"] = val

		val, err = v.DestinationPortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_number"] = val

		val, err = v.DestinationPortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_operator"] = val

		val, err = v.DestinationPortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_port_range"] = val

		val, err = v.DestinationPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination_prefix"] = val

		val, err = v.FirstFragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["first_fragment"] = val

		val, err = v.Fragment.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fragment"] = val

		val, err = v.IcmpCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_code"] = val

		val, err = v.IcmpTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_name"] = val

		val, err = v.IcmpTypeNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["icmp_type_number"] = val

		val, err = v.ProtocolName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_name"] = val

		val, err = v.ProtocolNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol_number"] = val

		val, err = v.SourcePortName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_name"] = val

		val, err = v.SourcePortNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_number"] = val

		val, err = v.SourcePortOperator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_operator"] = val

		val, err = v.SourcePortRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_port_range"] = val

		val, err = v.SourcePrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_prefix"] = val

		val, err = v.TcpFlags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tcp_flags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpEntryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpEntryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpEntryValue) String() string {
	return "IpEntryValue"
}

func (v IpEntryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var action basetypes.ObjectValue

	if v.Action.IsNull() {
		action = types.ObjectNull(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Action.IsUnknown() {
		action = types.ObjectUnknown(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Action.IsNull() && !v.Action.IsUnknown() {
		action = types.ObjectValueMust(
			ActionValue{}.AttributeTypes(ctx),
			v.Action.Attributes(),
		)
	}

	var icmpCodeVal basetypes.ListValue
	switch {
	case v.IcmpCode.IsUnknown():
		icmpCodeVal = types.ListUnknown(types.Int64Type)
	case v.IcmpCode.IsNull():
		icmpCodeVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		icmpCodeVal, d = types.ListValue(types.Int64Type, v.IcmpCode.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"action": basetypes.ObjectType{
				AttrTypes: ActionValue{}.AttributeTypes(ctx),
			},
			"destination_port_name":     basetypes.StringType{},
			"destination_port_number":   basetypes.Int64Type{},
			"destination_port_operator": basetypes.StringType{},
			"destination_port_range":    basetypes.StringType{},
			"destination_prefix":        basetypes.StringType{},
			"first_fragment":            basetypes.BoolType{},
			"fragment":                  basetypes.BoolType{},
			"icmp_code": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"icmp_type_name":       basetypes.StringType{},
			"icmp_type_number":     basetypes.Int64Type{},
			"protocol_name":        basetypes.StringType{},
			"protocol_number":      basetypes.Int64Type{},
			"source_port_name":     basetypes.StringType{},
			"source_port_number":   basetypes.Int64Type{},
			"source_port_operator": basetypes.StringType{},
			"source_port_range":    basetypes.StringType{},
			"source_prefix":        basetypes.StringType{},
			"tcp_flags":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"first_fragment":            basetypes.BoolType{},
		"fragment":                  basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":       basetypes.StringType{},
		"icmp_type_number":     basetypes.Int64Type{},
		"protocol_name":        basetypes.StringType{},
		"protocol_number":      basetypes.Int64Type{},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":                    action,
			"destination_port_name":     v.DestinationPortName,
			"destination_port_number":   v.DestinationPortNumber,
			"destination_port_operator": v.DestinationPortOperator,
			"destination_port_range":    v.DestinationPortRange,
			"destination_prefix":        v.DestinationPrefix,
			"first_fragment":            v.FirstFragment,
			"fragment":                  v.Fragment,
			"icmp_code":                 icmpCodeVal,
			"icmp_type_name":            v.IcmpTypeName,
			"icmp_type_number":          v.IcmpTypeNumber,
			"protocol_name":             v.ProtocolName,
			"protocol_number":           v.ProtocolNumber,
			"source_port_name":          v.SourcePortName,
			"source_port_number":        v.SourcePortNumber,
			"source_port_operator":      v.SourcePortOperator,
			"source_port_range":         v.SourcePortRange,
			"source_prefix":             v.SourcePrefix,
			"tcp_flags":                 v.TcpFlags,
		})

	return objVal, diags
}

func (v IpEntryValue) Equal(o attr.Value) bool {
	other, ok := o.(IpEntryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.DestinationPortName.Equal(other.DestinationPortName) {
		return false
	}

	if !v.DestinationPortNumber.Equal(other.DestinationPortNumber) {
		return false
	}

	if !v.DestinationPortOperator.Equal(other.DestinationPortOperator) {
		return false
	}

	if !v.DestinationPortRange.Equal(other.DestinationPortRange) {
		return false
	}

	if !v.DestinationPrefix.Equal(other.DestinationPrefix) {
		return false
	}

	if !v.FirstFragment.Equal(other.FirstFragment) {
		return false
	}

	if !v.Fragment.Equal(other.Fragment) {
		return false
	}

	if !v.IcmpCode.Equal(other.IcmpCode) {
		return false
	}

	if !v.IcmpTypeName.Equal(other.IcmpTypeName) {
		return false
	}

	if !v.IcmpTypeNumber.Equal(other.IcmpTypeNumber) {
		return false
	}

	if !v.ProtocolName.Equal(other.ProtocolName) {
		return false
	}

	if !v.ProtocolNumber.Equal(other.ProtocolNumber) {
		return false
	}

	if !v.SourcePortName.Equal(other.SourcePortName) {
		return false
	}

	if !v.SourcePortNumber.Equal(other.SourcePortNumber) {
		return false
	}

	if !v.SourcePortOperator.Equal(other.SourcePortOperator) {
		return false
	}

	if !v.SourcePortRange.Equal(other.SourcePortRange) {
		return false
	}

	if !v.SourcePrefix.Equal(other.SourcePrefix) {
		return false
	}

	if !v.TcpFlags.Equal(other.TcpFlags) {
		return false
	}

	return true
}

func (v IpEntryValue) Type(ctx context.Context) attr.Type {
	return IpEntryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpEntryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"destination_port_name":     basetypes.StringType{},
		"destination_port_number":   basetypes.Int64Type{},
		"destination_port_operator": basetypes.StringType{},
		"destination_port_range":    basetypes.StringType{},
		"destination_prefix":        basetypes.StringType{},
		"first_fragment":            basetypes.BoolType{},
		"fragment":                  basetypes.BoolType{},
		"icmp_code": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"icmp_type_name":       basetypes.StringType{},
		"icmp_type_number":     basetypes.Int64Type{},
		"protocol_name":        basetypes.StringType{},
		"protocol_number":      basetypes.Int64Type{},
		"source_port_name":     basetypes.StringType{},
		"source_port_number":   basetypes.Int64Type{},
		"source_port_operator": basetypes.StringType{},
		"source_port_range":    basetypes.StringType{},
		"source_prefix":        basetypes.StringType{},
		"tcp_flags":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ActionType{}

type ActionType struct {
	basetypes.ObjectType
}

func (t ActionType) Equal(o attr.Type) bool {
	other, ok := o.(ActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionType) String() string {
	return "ActionType"
}

func (t ActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return nil, diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	dscpRewriteValueAttribute, ok := attributes["dscp_rewrite_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_rewrite_value is missing from object`)

		return nil, diags
	}

	dscpRewriteValueVal, ok := dscpRewriteValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_rewrite_value expected to be basetypes.Int64Value, was: %T`, dscpRewriteValueAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return nil, diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		DscpRewriteValue:     dscpRewriteValueVal,
		ForwardingClass:      forwardingClassVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewActionValueNull() ActionValue {
	return ActionValue{
		state: attr.ValueStateNull,
	}
}

func NewActionValueUnknown() ActionValue {
	return ActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionValue Attribute Value",
				"While creating a ActionValue value, a missing attribute value was detected. "+
					"A ActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionValue Attribute Type",
				"While creating a ActionValue value, an invalid attribute value was detected. "+
					"A ActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionValue Attribute Value",
				"While creating a ActionValue value, an extra attribute value was detected. "+
					"A ActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return NewActionValueUnknown(), diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	dscpRewriteValueAttribute, ok := attributes["dscp_rewrite_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_rewrite_value is missing from object`)

		return NewActionValueUnknown(), diags
	}

	dscpRewriteValueVal, ok := dscpRewriteValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_rewrite_value expected to be basetypes.Int64Value, was: %T`, dscpRewriteValueAttribute))
	}

	forwardingClassAttribute, ok := attributes["forwarding_class"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class is missing from object`)

		return NewActionValueUnknown(), diags
	}

	forwardingClassVal, ok := forwardingClassAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class expected to be basetypes.StringValue, was: %T`, forwardingClassAttribute))
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	return ActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		DscpRewriteValue:     dscpRewriteValueVal,
		ForwardingClass:      forwardingClassVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionValue {
	object, diags := NewActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionValueMust(ActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionType) ValueType(ctx context.Context) attr.Value {
	return ActionValue{}
}

var _ basetypes.ObjectValuable = ActionValue{}

type ActionValue struct {
	DropProbabilityLevel basetypes.StringValue `tfsdk:"drop_probability_level"`
	DscpRewriteValue     basetypes.Int64Value  `tfsdk:"dscp_rewrite_value"`
	ForwardingClass      basetypes.StringValue `tfsdk:"forwarding_class"`
	state                attr.ValueState
}

func (v ActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability_level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dscp_rewrite_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["forwarding_class"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DropProbabilityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_level"] = val

		val, err = v.DscpRewriteValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp_rewrite_value"] = val

		val, err = v.ForwardingClass.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_class"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionValue) String() string {
	return "ActionValue"
}

func (v ActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
		"dscp_rewrite_value":     basetypes.Int64Type{},
		"forwarding_class":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability_level": v.DropProbabilityLevel,
			"dscp_rewrite_value":     v.DscpRewriteValue,
			"forwarding_class":       v.ForwardingClass,
		})

	return objVal, diags
}

func (v ActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbabilityLevel.Equal(other.DropProbabilityLevel) {
		return false
	}

	if !v.DscpRewriteValue.Equal(other.DscpRewriteValue) {
		return false
	}

	if !v.ForwardingClass.Equal(other.ForwardingClass) {
		return false
	}

	return true
}

func (v ActionValue) Type(ctx context.Context) attr.Type {
	return ActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
		"dscp_rewrite_value":     basetypes.Int64Type{},
		"forwarding_class":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ForwardingClassToQueueMappingType{}

type ForwardingClassToQueueMappingType struct {
	basetypes.ObjectType
}

func (t ForwardingClassToQueueMappingType) Equal(o attr.Type) bool {
	other, ok := o.(ForwardingClassToQueueMappingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ForwardingClassToQueueMappingType) String() string {
	return "ForwardingClassToQueueMappingType"
}

func (t ForwardingClassToQueueMappingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return nil, diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ForwardingClassToQueueMappingValue{
		ForwardingClasses: forwardingClassesVal,
		Queue:             queueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassToQueueMappingValueNull() ForwardingClassToQueueMappingValue {
	return ForwardingClassToQueueMappingValue{
		state: attr.ValueStateNull,
	}
}

func NewForwardingClassToQueueMappingValueUnknown() ForwardingClassToQueueMappingValue {
	return ForwardingClassToQueueMappingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewForwardingClassToQueueMappingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ForwardingClassToQueueMappingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ForwardingClassToQueueMappingValue Attribute Value",
				"While creating a ForwardingClassToQueueMappingValue value, a missing attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ForwardingClassToQueueMappingValue Attribute Type",
				"While creating a ForwardingClassToQueueMappingValue value, an invalid attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ForwardingClassToQueueMappingValue Attribute Value",
				"While creating a ForwardingClassToQueueMappingValue value, an extra attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ForwardingClassToQueueMappingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	if diags.HasError() {
		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	return ForwardingClassToQueueMappingValue{
		ForwardingClasses: forwardingClassesVal,
		Queue:             queueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassToQueueMappingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ForwardingClassToQueueMappingValue {
	object, diags := NewForwardingClassToQueueMappingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewForwardingClassToQueueMappingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ForwardingClassToQueueMappingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewForwardingClassToQueueMappingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewForwardingClassToQueueMappingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewForwardingClassToQueueMappingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewForwardingClassToQueueMappingValueMust(ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ForwardingClassToQueueMappingType) ValueType(ctx context.Context) attr.Value {
	return ForwardingClassToQueueMappingValue{}
}

var _ basetypes.ObjectValuable = ForwardingClassToQueueMappingValue{}

type ForwardingClassToQueueMappingValue struct {
	ForwardingClasses basetypes.ListValue   `tfsdk:"forwarding_classes"`
	Queue             basetypes.StringValue `tfsdk:"queue"`
	state             attr.ValueState
}

func (v ForwardingClassToQueueMappingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["queue"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		val, err = v.Queue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ForwardingClassToQueueMappingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ForwardingClassToQueueMappingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ForwardingClassToQueueMappingValue) String() string {
	return "ForwardingClassToQueueMappingValue"
}

func (v ForwardingClassToQueueMappingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var forwardingClassesVal basetypes.ListValue
	switch {
	case v.ForwardingClasses.IsUnknown():
		forwardingClassesVal = types.ListUnknown(types.StringType)
	case v.ForwardingClasses.IsNull():
		forwardingClassesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingClassesVal, d = types.ListValue(types.StringType, v.ForwardingClasses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"queue": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"queue": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"forwarding_classes": forwardingClassesVal,
			"queue":              v.Queue,
		})

	return objVal, diags
}

func (v ForwardingClassToQueueMappingValue) Equal(o attr.Value) bool {
	other, ok := o.(ForwardingClassToQueueMappingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	if !v.Queue.Equal(other.Queue) {
		return false
	}

	return true
}

func (v ForwardingClassToQueueMappingValue) Type(ctx context.Context) attr.Type {
	return ForwardingClassToQueueMappingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ForwardingClassToQueueMappingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"queue": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PolicersType{}

type PolicersType struct {
	basetypes.ObjectType
}

func (t PolicersType) Equal(o attr.Type) bool {
	other, ok := o.(PolicersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PolicersType) String() string {
	return "PolicersType"
}

func (t PolicersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return nil, diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	committedRateAttribute, ok := attributes["committed_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_rate is missing from object`)

		return nil, diags
	}

	committedRateVal, ok := committedRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_rate expected to be basetypes.Int64Value, was: %T`, committedRateAttribute))
	}

	committedRatePercentAttribute, ok := attributes["committed_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_rate_percent is missing from object`)

		return nil, diags
	}

	committedRatePercentVal, ok := committedRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_rate_percent expected to be basetypes.Int64Value, was: %T`, committedRatePercentAttribute))
	}

	exceedActionAttribute, ok := attributes["exceed_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exceed_action is missing from object`)

		return nil, diags
	}

	exceedActionVal, ok := exceedActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exceed_action expected to be basetypes.ObjectValue, was: %T`, exceedActionAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return nil, diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	minInterfaceSpeedAttribute, ok := attributes["min_interface_speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_interface_speed is missing from object`)

		return nil, diags
	}

	minInterfaceSpeedVal, ok := minInterfaceSpeedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_interface_speed expected to be basetypes.Int64Value, was: %T`, minInterfaceSpeedAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return nil, diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	peakRatePercentAttribute, ok := attributes["peak_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate_percent is missing from object`)

		return nil, diags
	}

	peakRatePercentVal, ok := peakRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate_percent expected to be basetypes.Int64Value, was: %T`, peakRatePercentAttribute))
	}

	violateActionAttribute, ok := attributes["violate_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`violate_action is missing from object`)

		return nil, diags
	}

	violateActionVal, ok := violateActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`violate_action expected to be basetypes.ObjectValue, was: %T`, violateActionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PolicersValue{
		CommittedBurstSize:   committedBurstSizeVal,
		CommittedRate:        committedRateVal,
		CommittedRatePercent: committedRatePercentVal,
		ExceedAction:         exceedActionVal,
		ForwardingClasses:    forwardingClassesVal,
		MaximumBurstSize:     maximumBurstSizeVal,
		MinInterfaceSpeed:    minInterfaceSpeedVal,
		PeakRate:             peakRateVal,
		PeakRatePercent:      peakRatePercentVal,
		ViolateAction:        violateActionVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicersValueNull() PolicersValue {
	return PolicersValue{
		state: attr.ValueStateNull,
	}
}

func NewPolicersValueUnknown() PolicersValue {
	return PolicersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPolicersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PolicersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PolicersValue Attribute Value",
				"While creating a PolicersValue value, a missing attribute value was detected. "+
					"A PolicersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PolicersValue Attribute Type",
				"While creating a PolicersValue value, an invalid attribute value was detected. "+
					"A PolicersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PolicersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PolicersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PolicersValue Attribute Value",
				"While creating a PolicersValue value, an extra attribute value was detected. "+
					"A PolicersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PolicersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPolicersValueUnknown(), diags
	}

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	committedRateAttribute, ok := attributes["committed_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_rate is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	committedRateVal, ok := committedRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_rate expected to be basetypes.Int64Value, was: %T`, committedRateAttribute))
	}

	committedRatePercentAttribute, ok := attributes["committed_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_rate_percent is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	committedRatePercentVal, ok := committedRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_rate_percent expected to be basetypes.Int64Value, was: %T`, committedRatePercentAttribute))
	}

	exceedActionAttribute, ok := attributes["exceed_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exceed_action is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	exceedActionVal, ok := exceedActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exceed_action expected to be basetypes.ObjectValue, was: %T`, exceedActionAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	minInterfaceSpeedAttribute, ok := attributes["min_interface_speed"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_interface_speed is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	minInterfaceSpeedVal, ok := minInterfaceSpeedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_interface_speed expected to be basetypes.Int64Value, was: %T`, minInterfaceSpeedAttribute))
	}

	peakRateAttribute, ok := attributes["peak_rate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	peakRateVal, ok := peakRateAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate expected to be basetypes.Int64Value, was: %T`, peakRateAttribute))
	}

	peakRatePercentAttribute, ok := attributes["peak_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peak_rate_percent is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	peakRatePercentVal, ok := peakRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peak_rate_percent expected to be basetypes.Int64Value, was: %T`, peakRatePercentAttribute))
	}

	violateActionAttribute, ok := attributes["violate_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`violate_action is missing from object`)

		return NewPolicersValueUnknown(), diags
	}

	violateActionVal, ok := violateActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`violate_action expected to be basetypes.ObjectValue, was: %T`, violateActionAttribute))
	}

	if diags.HasError() {
		return NewPolicersValueUnknown(), diags
	}

	return PolicersValue{
		CommittedBurstSize:   committedBurstSizeVal,
		CommittedRate:        committedRateVal,
		CommittedRatePercent: committedRatePercentVal,
		ExceedAction:         exceedActionVal,
		ForwardingClasses:    forwardingClassesVal,
		MaximumBurstSize:     maximumBurstSizeVal,
		MinInterfaceSpeed:    minInterfaceSpeedVal,
		PeakRate:             peakRateVal,
		PeakRatePercent:      peakRatePercentVal,
		ViolateAction:        violateActionVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPolicersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PolicersValue {
	object, diags := NewPolicersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPolicersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PolicersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPolicersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPolicersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPolicersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPolicersValueMust(PolicersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PolicersType) ValueType(ctx context.Context) attr.Value {
	return PolicersValue{}
}

var _ basetypes.ObjectValuable = PolicersValue{}

type PolicersValue struct {
	CommittedBurstSize   basetypes.Int64Value  `tfsdk:"committed_burst_size"`
	CommittedRate        basetypes.Int64Value  `tfsdk:"committed_rate"`
	CommittedRatePercent basetypes.Int64Value  `tfsdk:"committed_rate_percent"`
	ExceedAction         basetypes.ObjectValue `tfsdk:"exceed_action"`
	ForwardingClasses    basetypes.ListValue   `tfsdk:"forwarding_classes"`
	MaximumBurstSize     basetypes.Int64Value  `tfsdk:"maximum_burst_size"`
	MinInterfaceSpeed    basetypes.Int64Value  `tfsdk:"min_interface_speed"`
	PeakRate             basetypes.Int64Value  `tfsdk:"peak_rate"`
	PeakRatePercent      basetypes.Int64Value  `tfsdk:"peak_rate_percent"`
	ViolateAction        basetypes.ObjectValue `tfsdk:"violate_action"`
	state                attr.ValueState
}

func (v PolicersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["committed_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["committed_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["committed_rate_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["exceed_action"] = basetypes.ObjectType{
		AttrTypes: ExceedActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: ForwardingClassesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["maximum_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_interface_speed"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["peak_rate"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["peak_rate_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["violate_action"] = basetypes.ObjectType{
		AttrTypes: ViolateActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.CommittedBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["committed_burst_size"] = val

		val, err = v.CommittedRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["committed_rate"] = val

		val, err = v.CommittedRatePercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["committed_rate_percent"] = val

		val, err = v.ExceedAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exceed_action"] = val

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		val, err = v.MaximumBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maximum_burst_size"] = val

		val, err = v.MinInterfaceSpeed.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_interface_speed"] = val

		val, err = v.PeakRate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peak_rate"] = val

		val, err = v.PeakRatePercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peak_rate_percent"] = val

		val, err = v.ViolateAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["violate_action"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PolicersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PolicersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PolicersValue) String() string {
	return "PolicersValue"
}

func (v PolicersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var exceedAction basetypes.ObjectValue

	if v.ExceedAction.IsNull() {
		exceedAction = types.ObjectNull(
			ExceedActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.ExceedAction.IsUnknown() {
		exceedAction = types.ObjectUnknown(
			ExceedActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ExceedAction.IsNull() && !v.ExceedAction.IsUnknown() {
		exceedAction = types.ObjectValueMust(
			ExceedActionValue{}.AttributeTypes(ctx),
			v.ExceedAction.Attributes(),
		)
	}

	forwardingClasses := types.ListValueMust(
		ForwardingClassesType{
			basetypes.ObjectType{
				AttrTypes: ForwardingClassesValue{}.AttributeTypes(ctx),
			},
		},
		v.ForwardingClasses.Elements(),
	)

	if v.ForwardingClasses.IsNull() {
		forwardingClasses = types.ListNull(
			ForwardingClassesType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ForwardingClasses.IsUnknown() {
		forwardingClasses = types.ListUnknown(
			ForwardingClassesType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var violateAction basetypes.ObjectValue

	if v.ViolateAction.IsNull() {
		violateAction = types.ObjectNull(
			ViolateActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.ViolateAction.IsUnknown() {
		violateAction = types.ObjectUnknown(
			ViolateActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ViolateAction.IsNull() && !v.ViolateAction.IsUnknown() {
		violateAction = types.ObjectValueMust(
			ViolateActionValue{}.AttributeTypes(ctx),
			v.ViolateAction.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"committed_burst_size":   basetypes.Int64Type{},
		"committed_rate":         basetypes.Int64Type{},
		"committed_rate_percent": basetypes.Int64Type{},
		"exceed_action": basetypes.ObjectType{
			AttrTypes: ExceedActionValue{}.AttributeTypes(ctx),
		},
		"forwarding_classes": basetypes.ListType{
			ElemType: ForwardingClassesValue{}.Type(ctx),
		},
		"maximum_burst_size":  basetypes.Int64Type{},
		"min_interface_speed": basetypes.Int64Type{},
		"peak_rate":           basetypes.Int64Type{},
		"peak_rate_percent":   basetypes.Int64Type{},
		"violate_action": basetypes.ObjectType{
			AttrTypes: ViolateActionValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"committed_burst_size":   v.CommittedBurstSize,
			"committed_rate":         v.CommittedRate,
			"committed_rate_percent": v.CommittedRatePercent,
			"exceed_action":          exceedAction,
			"forwarding_classes":     forwardingClasses,
			"maximum_burst_size":     v.MaximumBurstSize,
			"min_interface_speed":    v.MinInterfaceSpeed,
			"peak_rate":              v.PeakRate,
			"peak_rate_percent":      v.PeakRatePercent,
			"violate_action":         violateAction,
		})

	return objVal, diags
}

func (v PolicersValue) Equal(o attr.Value) bool {
	other, ok := o.(PolicersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommittedBurstSize.Equal(other.CommittedBurstSize) {
		return false
	}

	if !v.CommittedRate.Equal(other.CommittedRate) {
		return false
	}

	if !v.CommittedRatePercent.Equal(other.CommittedRatePercent) {
		return false
	}

	if !v.ExceedAction.Equal(other.ExceedAction) {
		return false
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	if !v.MaximumBurstSize.Equal(other.MaximumBurstSize) {
		return false
	}

	if !v.MinInterfaceSpeed.Equal(other.MinInterfaceSpeed) {
		return false
	}

	if !v.PeakRate.Equal(other.PeakRate) {
		return false
	}

	if !v.PeakRatePercent.Equal(other.PeakRatePercent) {
		return false
	}

	if !v.ViolateAction.Equal(other.ViolateAction) {
		return false
	}

	return true
}

func (v PolicersValue) Type(ctx context.Context) attr.Type {
	return PolicersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PolicersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"committed_burst_size":   basetypes.Int64Type{},
		"committed_rate":         basetypes.Int64Type{},
		"committed_rate_percent": basetypes.Int64Type{},
		"exceed_action": basetypes.ObjectType{
			AttrTypes: ExceedActionValue{}.AttributeTypes(ctx),
		},
		"forwarding_classes": basetypes.ListType{
			ElemType: ForwardingClassesValue{}.Type(ctx),
		},
		"maximum_burst_size":  basetypes.Int64Type{},
		"min_interface_speed": basetypes.Int64Type{},
		"peak_rate":           basetypes.Int64Type{},
		"peak_rate_percent":   basetypes.Int64Type{},
		"violate_action": basetypes.ObjectType{
			AttrTypes: ViolateActionValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = ExceedActionType{}

type ExceedActionType struct {
	basetypes.ObjectType
}

func (t ExceedActionType) Equal(o attr.Type) bool {
	other, ok := o.(ExceedActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExceedActionType) String() string {
	return "ExceedActionType"
}

func (t ExceedActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return nil, diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExceedActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewExceedActionValueNull() ExceedActionValue {
	return ExceedActionValue{
		state: attr.ValueStateNull,
	}
}

func NewExceedActionValueUnknown() ExceedActionValue {
	return ExceedActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExceedActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExceedActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExceedActionValue Attribute Value",
				"While creating a ExceedActionValue value, a missing attribute value was detected. "+
					"A ExceedActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExceedActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExceedActionValue Attribute Type",
				"While creating a ExceedActionValue value, an invalid attribute value was detected. "+
					"A ExceedActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExceedActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExceedActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExceedActionValue Attribute Value",
				"While creating a ExceedActionValue value, an extra attribute value was detected. "+
					"A ExceedActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExceedActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExceedActionValueUnknown(), diags
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return NewExceedActionValueUnknown(), diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	if diags.HasError() {
		return NewExceedActionValueUnknown(), diags
	}

	return ExceedActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewExceedActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExceedActionValue {
	object, diags := NewExceedActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExceedActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExceedActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExceedActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExceedActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExceedActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExceedActionValueMust(ExceedActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExceedActionType) ValueType(ctx context.Context) attr.Value {
	return ExceedActionValue{}
}

var _ basetypes.ObjectValuable = ExceedActionValue{}

type ExceedActionValue struct {
	DropProbabilityLevel basetypes.StringValue `tfsdk:"drop_probability_level"`
	state                attr.ValueState
}

func (v ExceedActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability_level"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DropProbabilityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_level"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExceedActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExceedActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExceedActionValue) String() string {
	return "ExceedActionValue"
}

func (v ExceedActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability_level": v.DropProbabilityLevel,
		})

	return objVal, diags
}

func (v ExceedActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ExceedActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbabilityLevel.Equal(other.DropProbabilityLevel) {
		return false
	}

	return true
}

func (v ExceedActionValue) Type(ctx context.Context) attr.Type {
	return ExceedActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExceedActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ForwardingClassesType{}

type ForwardingClassesType struct {
	basetypes.ObjectType
}

func (t ForwardingClassesType) Equal(o attr.Type) bool {
	other, ok := o.(ForwardingClassesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ForwardingClassesType) String() string {
	return "ForwardingClassesType"
}

func (t ForwardingClassesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	forwardingTypesAttribute, ok := attributes["forwarding_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_types is missing from object`)

		return nil, diags
	}

	forwardingTypesVal, ok := forwardingTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_types expected to be basetypes.ListValue, was: %T`, forwardingTypesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ForwardingClassesValue{
		ForwardingClasses: forwardingClassesVal,
		ForwardingTypes:   forwardingTypesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassesValueNull() ForwardingClassesValue {
	return ForwardingClassesValue{
		state: attr.ValueStateNull,
	}
}

func NewForwardingClassesValueUnknown() ForwardingClassesValue {
	return ForwardingClassesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewForwardingClassesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ForwardingClassesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ForwardingClassesValue Attribute Value",
				"While creating a ForwardingClassesValue value, a missing attribute value was detected. "+
					"A ForwardingClassesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ForwardingClassesValue Attribute Type",
				"While creating a ForwardingClassesValue value, an invalid attribute value was detected. "+
					"A ForwardingClassesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ForwardingClassesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ForwardingClassesValue Attribute Value",
				"While creating a ForwardingClassesValue value, an extra attribute value was detected. "+
					"A ForwardingClassesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ForwardingClassesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewForwardingClassesValueUnknown(), diags
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewForwardingClassesValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	forwardingTypesAttribute, ok := attributes["forwarding_types"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_types is missing from object`)

		return NewForwardingClassesValueUnknown(), diags
	}

	forwardingTypesVal, ok := forwardingTypesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_types expected to be basetypes.ListValue, was: %T`, forwardingTypesAttribute))
	}

	if diags.HasError() {
		return NewForwardingClassesValueUnknown(), diags
	}

	return ForwardingClassesValue{
		ForwardingClasses: forwardingClassesVal,
		ForwardingTypes:   forwardingTypesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ForwardingClassesValue {
	object, diags := NewForwardingClassesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewForwardingClassesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ForwardingClassesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewForwardingClassesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewForwardingClassesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewForwardingClassesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewForwardingClassesValueMust(ForwardingClassesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ForwardingClassesType) ValueType(ctx context.Context) attr.Value {
	return ForwardingClassesValue{}
}

var _ basetypes.ObjectValuable = ForwardingClassesValue{}

type ForwardingClassesValue struct {
	ForwardingClasses basetypes.ListValue `tfsdk:"forwarding_classes"`
	ForwardingTypes   basetypes.ListValue `tfsdk:"forwarding_types"`
	state             attr.ValueState
}

func (v ForwardingClassesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["forwarding_types"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		val, err = v.ForwardingTypes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_types"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ForwardingClassesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ForwardingClassesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ForwardingClassesValue) String() string {
	return "ForwardingClassesValue"
}

func (v ForwardingClassesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var forwardingClassesVal basetypes.ListValue
	switch {
	case v.ForwardingClasses.IsUnknown():
		forwardingClassesVal = types.ListUnknown(types.StringType)
	case v.ForwardingClasses.IsNull():
		forwardingClassesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingClassesVal, d = types.ListValue(types.StringType, v.ForwardingClasses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"forwarding_types": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var forwardingTypesVal basetypes.ListValue
	switch {
	case v.ForwardingTypes.IsUnknown():
		forwardingTypesVal = types.ListUnknown(types.StringType)
	case v.ForwardingTypes.IsNull():
		forwardingTypesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingTypesVal, d = types.ListValue(types.StringType, v.ForwardingTypes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"forwarding_types": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"forwarding_types": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"forwarding_classes": forwardingClassesVal,
			"forwarding_types":   forwardingTypesVal,
		})

	return objVal, diags
}

func (v ForwardingClassesValue) Equal(o attr.Value) bool {
	other, ok := o.(ForwardingClassesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	if !v.ForwardingTypes.Equal(other.ForwardingTypes) {
		return false
	}

	return true
}

func (v ForwardingClassesValue) Type(ctx context.Context) attr.Type {
	return ForwardingClassesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ForwardingClassesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"forwarding_types": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ViolateActionType{}

type ViolateActionType struct {
	basetypes.ObjectType
}

func (t ViolateActionType) Equal(o attr.Type) bool {
	other, ok := o.(ViolateActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ViolateActionType) String() string {
	return "ViolateActionType"
}

func (t ViolateActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return nil, diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ViolateActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewViolateActionValueNull() ViolateActionValue {
	return ViolateActionValue{
		state: attr.ValueStateNull,
	}
}

func NewViolateActionValueUnknown() ViolateActionValue {
	return ViolateActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewViolateActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ViolateActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ViolateActionValue Attribute Value",
				"While creating a ViolateActionValue value, a missing attribute value was detected. "+
					"A ViolateActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViolateActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ViolateActionValue Attribute Type",
				"While creating a ViolateActionValue value, an invalid attribute value was detected. "+
					"A ViolateActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ViolateActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ViolateActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ViolateActionValue Attribute Value",
				"While creating a ViolateActionValue value, an extra attribute value was detected. "+
					"A ViolateActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ViolateActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewViolateActionValueUnknown(), diags
	}

	dropProbabilityLevelAttribute, ok := attributes["drop_probability_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_level is missing from object`)

		return NewViolateActionValueUnknown(), diags
	}

	dropProbabilityLevelVal, ok := dropProbabilityLevelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_level expected to be basetypes.StringValue, was: %T`, dropProbabilityLevelAttribute))
	}

	if diags.HasError() {
		return NewViolateActionValueUnknown(), diags
	}

	return ViolateActionValue{
		DropProbabilityLevel: dropProbabilityLevelVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewViolateActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ViolateActionValue {
	object, diags := NewViolateActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewViolateActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ViolateActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewViolateActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewViolateActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewViolateActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewViolateActionValueMust(ViolateActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ViolateActionType) ValueType(ctx context.Context) attr.Value {
	return ViolateActionValue{}
}

var _ basetypes.ObjectValuable = ViolateActionValue{}

type ViolateActionValue struct {
	DropProbabilityLevel basetypes.StringValue `tfsdk:"drop_probability_level"`
	state                attr.ValueState
}

func (v ViolateActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability_level"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DropProbabilityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_level"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ViolateActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ViolateActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ViolateActionValue) String() string {
	return "ViolateActionValue"
}

func (v ViolateActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability_level": v.DropProbabilityLevel,
		})

	return objVal, diags
}

func (v ViolateActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ViolateActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbabilityLevel.Equal(other.DropProbabilityLevel) {
		return false
	}

	return true
}

func (v ViolateActionValue) Type(ctx context.Context) attr.Type {
	return ViolateActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ViolateActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability_level": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QueueManagementType{}

type QueueManagementType struct {
	basetypes.ObjectType
}

func (t QueueManagementType) Equal(o attr.Type) bool {
	other, ok := o.(QueueManagementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueueManagementType) String() string {
	return "QueueManagementType"
}

func (t QueueManagementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	pfcReservedBufferPercentAttribute, ok := attributes["pfc_reserved_buffer_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_reserved_buffer_percent is missing from object`)

		return nil, diags
	}

	pfcReservedBufferPercentVal, ok := pfcReservedBufferPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_reserved_buffer_percent expected to be basetypes.Int64Value, was: %T`, pfcReservedBufferPercentAttribute))
	}

	queuesAttribute, ok := attributes["queues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queues is missing from object`)

		return nil, diags
	}

	queuesVal, ok := queuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queues expected to be basetypes.ListValue, was: %T`, queuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueueManagementValue{
		PfcReservedBufferPercent: pfcReservedBufferPercentVal,
		Queues:                   queuesVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewQueueManagementValueNull() QueueManagementValue {
	return QueueManagementValue{
		state: attr.ValueStateNull,
	}
}

func NewQueueManagementValueUnknown() QueueManagementValue {
	return QueueManagementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueueManagementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueueManagementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueueManagementValue Attribute Value",
				"While creating a QueueManagementValue value, a missing attribute value was detected. "+
					"A QueueManagementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueueManagementValue Attribute Type",
				"While creating a QueueManagementValue value, an invalid attribute value was detected. "+
					"A QueueManagementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueueManagementValue Attribute Value",
				"While creating a QueueManagementValue value, an extra attribute value was detected. "+
					"A QueueManagementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueueManagementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueueManagementValueUnknown(), diags
	}

	pfcReservedBufferPercentAttribute, ok := attributes["pfc_reserved_buffer_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_reserved_buffer_percent is missing from object`)

		return NewQueueManagementValueUnknown(), diags
	}

	pfcReservedBufferPercentVal, ok := pfcReservedBufferPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_reserved_buffer_percent expected to be basetypes.Int64Value, was: %T`, pfcReservedBufferPercentAttribute))
	}

	queuesAttribute, ok := attributes["queues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queues is missing from object`)

		return NewQueueManagementValueUnknown(), diags
	}

	queuesVal, ok := queuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queues expected to be basetypes.ListValue, was: %T`, queuesAttribute))
	}

	if diags.HasError() {
		return NewQueueManagementValueUnknown(), diags
	}

	return QueueManagementValue{
		PfcReservedBufferPercent: pfcReservedBufferPercentVal,
		Queues:                   queuesVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewQueueManagementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueueManagementValue {
	object, diags := NewQueueManagementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueueManagementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueueManagementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueueManagementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueueManagementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueueManagementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueueManagementValueMust(QueueManagementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueueManagementType) ValueType(ctx context.Context) attr.Value {
	return QueueManagementValue{}
}

var _ basetypes.ObjectValuable = QueueManagementValue{}

type QueueManagementValue struct {
	PfcReservedBufferPercent basetypes.Int64Value `tfsdk:"pfc_reserved_buffer_percent"`
	Queues                   basetypes.ListValue  `tfsdk:"queues"`
	state                    attr.ValueState
}

func (v QueueManagementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["pfc_reserved_buffer_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["queues"] = basetypes.ListType{
		ElemType: QueuesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PfcReservedBufferPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_reserved_buffer_percent"] = val

		val, err = v.Queues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queues"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueueManagementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueueManagementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueueManagementValue) String() string {
	return "QueueManagementValue"
}

func (v QueueManagementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	queues := types.ListValueMust(
		QueuesType{
			basetypes.ObjectType{
				AttrTypes: QueuesValue{}.AttributeTypes(ctx),
			},
		},
		v.Queues.Elements(),
	)

	if v.Queues.IsNull() {
		queues = types.ListNull(
			QueuesType{
				basetypes.ObjectType{
					AttrTypes: QueuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Queues.IsUnknown() {
		queues = types.ListUnknown(
			QueuesType{
				basetypes.ObjectType{
					AttrTypes: QueuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"pfc_reserved_buffer_percent": basetypes.Int64Type{},
		"queues": basetypes.ListType{
			ElemType: QueuesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"pfc_reserved_buffer_percent": v.PfcReservedBufferPercent,
			"queues":                      queues,
		})

	return objVal, diags
}

func (v QueueManagementValue) Equal(o attr.Value) bool {
	other, ok := o.(QueueManagementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PfcReservedBufferPercent.Equal(other.PfcReservedBufferPercent) {
		return false
	}

	if !v.Queues.Equal(other.Queues) {
		return false
	}

	return true
}

func (v QueueManagementValue) Type(ctx context.Context) attr.Type {
	return QueueManagementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueueManagementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"pfc_reserved_buffer_percent": basetypes.Int64Type{},
		"queues": basetypes.ListType{
			ElemType: QueuesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = QueuesType{}

type QueuesType struct {
	basetypes.ObjectType
}

func (t QueuesType) Equal(o attr.Type) bool {
	other, ok := o.(QueuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueuesType) String() string {
	return "QueuesType"
}

func (t QueuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return nil, diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return nil, diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	pfcOffThresholdAttribute, ok := attributes["pfc_off_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_off_threshold is missing from object`)

		return nil, diags
	}

	pfcOffThresholdVal, ok := pfcOffThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_off_threshold expected to be basetypes.Int64Value, was: %T`, pfcOffThresholdAttribute))
	}

	pfcOnThresholdAttribute, ok := attributes["pfc_on_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_on_threshold is missing from object`)

		return nil, diags
	}

	pfcOnThresholdVal, ok := pfcOnThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_on_threshold expected to be basetypes.Int64Value, was: %T`, pfcOnThresholdAttribute))
	}

	pfcPauseFramePriorityAttribute, ok := attributes["pfc_pause_frame_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_pause_frame_priority is missing from object`)

		return nil, diags
	}

	pfcPauseFramePriorityVal, ok := pfcPauseFramePriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_pause_frame_priority expected to be basetypes.Int64Value, was: %T`, pfcPauseFramePriorityAttribute))
	}

	pfcReservedShareBufferPercentAttribute, ok := attributes["pfc_reserved_share_buffer_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_reserved_share_buffer_percent is missing from object`)

		return nil, diags
	}

	pfcReservedShareBufferPercentVal, ok := pfcReservedShareBufferPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_reserved_share_buffer_percent expected to be basetypes.Int64Value, was: %T`, pfcReservedShareBufferPercentAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return nil, diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueuesValue{
		CommittedBurstSize:            committedBurstSizeVal,
		MaximumBurstSize:              maximumBurstSizeVal,
		PfcOffThreshold:               pfcOffThresholdVal,
		PfcOnThreshold:                pfcOnThresholdVal,
		PfcPauseFramePriority:         pfcPauseFramePriorityVal,
		PfcReservedShareBufferPercent: pfcReservedShareBufferPercentVal,
		Queue:                         queueVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewQueuesValueNull() QueuesValue {
	return QueuesValue{
		state: attr.ValueStateNull,
	}
}

func NewQueuesValueUnknown() QueuesValue {
	return QueuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueuesValue Attribute Value",
				"While creating a QueuesValue value, a missing attribute value was detected. "+
					"A QueuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueuesValue Attribute Type",
				"While creating a QueuesValue value, an invalid attribute value was detected. "+
					"A QueuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueuesValue Attribute Value",
				"While creating a QueuesValue value, an extra attribute value was detected. "+
					"A QueuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueuesValueUnknown(), diags
	}

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	pfcOffThresholdAttribute, ok := attributes["pfc_off_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_off_threshold is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	pfcOffThresholdVal, ok := pfcOffThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_off_threshold expected to be basetypes.Int64Value, was: %T`, pfcOffThresholdAttribute))
	}

	pfcOnThresholdAttribute, ok := attributes["pfc_on_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_on_threshold is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	pfcOnThresholdVal, ok := pfcOnThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_on_threshold expected to be basetypes.Int64Value, was: %T`, pfcOnThresholdAttribute))
	}

	pfcPauseFramePriorityAttribute, ok := attributes["pfc_pause_frame_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_pause_frame_priority is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	pfcPauseFramePriorityVal, ok := pfcPauseFramePriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_pause_frame_priority expected to be basetypes.Int64Value, was: %T`, pfcPauseFramePriorityAttribute))
	}

	pfcReservedShareBufferPercentAttribute, ok := attributes["pfc_reserved_share_buffer_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_reserved_share_buffer_percent is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	pfcReservedShareBufferPercentVal, ok := pfcReservedShareBufferPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_reserved_share_buffer_percent expected to be basetypes.Int64Value, was: %T`, pfcReservedShareBufferPercentAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	if diags.HasError() {
		return NewQueuesValueUnknown(), diags
	}

	return QueuesValue{
		CommittedBurstSize:            committedBurstSizeVal,
		MaximumBurstSize:              maximumBurstSizeVal,
		PfcOffThreshold:               pfcOffThresholdVal,
		PfcOnThreshold:                pfcOnThresholdVal,
		PfcPauseFramePriority:         pfcPauseFramePriorityVal,
		PfcReservedShareBufferPercent: pfcReservedShareBufferPercentVal,
		Queue:                         queueVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewQueuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueuesValue {
	object, diags := NewQueuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueuesValueMust(QueuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueuesType) ValueType(ctx context.Context) attr.Value {
	return QueuesValue{}
}

var _ basetypes.ObjectValuable = QueuesValue{}

type QueuesValue struct {
	CommittedBurstSize            basetypes.Int64Value  `tfsdk:"committed_burst_size"`
	MaximumBurstSize              basetypes.Int64Value  `tfsdk:"maximum_burst_size"`
	PfcOffThreshold               basetypes.Int64Value  `tfsdk:"pfc_off_threshold"`
	PfcOnThreshold                basetypes.Int64Value  `tfsdk:"pfc_on_threshold"`
	PfcPauseFramePriority         basetypes.Int64Value  `tfsdk:"pfc_pause_frame_priority"`
	PfcReservedShareBufferPercent basetypes.Int64Value  `tfsdk:"pfc_reserved_share_buffer_percent"`
	Queue                         basetypes.StringValue `tfsdk:"queue"`
	state                         attr.ValueState
}

func (v QueuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["committed_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["maximum_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_off_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_on_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_pause_frame_priority"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_reserved_share_buffer_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["queue"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CommittedBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["committed_burst_size"] = val

		val, err = v.MaximumBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maximum_burst_size"] = val

		val, err = v.PfcOffThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_off_threshold"] = val

		val, err = v.PfcOnThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_on_threshold"] = val

		val, err = v.PfcPauseFramePriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_pause_frame_priority"] = val

		val, err = v.PfcReservedShareBufferPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_reserved_share_buffer_percent"] = val

		val, err = v.Queue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueuesValue) String() string {
	return "QueuesValue"
}

func (v QueuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"committed_burst_size":              basetypes.Int64Type{},
		"maximum_burst_size":                basetypes.Int64Type{},
		"pfc_off_threshold":                 basetypes.Int64Type{},
		"pfc_on_threshold":                  basetypes.Int64Type{},
		"pfc_pause_frame_priority":          basetypes.Int64Type{},
		"pfc_reserved_share_buffer_percent": basetypes.Int64Type{},
		"queue":                             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"committed_burst_size":              v.CommittedBurstSize,
			"maximum_burst_size":                v.MaximumBurstSize,
			"pfc_off_threshold":                 v.PfcOffThreshold,
			"pfc_on_threshold":                  v.PfcOnThreshold,
			"pfc_pause_frame_priority":          v.PfcPauseFramePriority,
			"pfc_reserved_share_buffer_percent": v.PfcReservedShareBufferPercent,
			"queue":                             v.Queue,
		})

	return objVal, diags
}

func (v QueuesValue) Equal(o attr.Value) bool {
	other, ok := o.(QueuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommittedBurstSize.Equal(other.CommittedBurstSize) {
		return false
	}

	if !v.MaximumBurstSize.Equal(other.MaximumBurstSize) {
		return false
	}

	if !v.PfcOffThreshold.Equal(other.PfcOffThreshold) {
		return false
	}

	if !v.PfcOnThreshold.Equal(other.PfcOnThreshold) {
		return false
	}

	if !v.PfcPauseFramePriority.Equal(other.PfcPauseFramePriority) {
		return false
	}

	if !v.PfcReservedShareBufferPercent.Equal(other.PfcReservedShareBufferPercent) {
		return false
	}

	if !v.Queue.Equal(other.Queue) {
		return false
	}

	return true
}

func (v QueuesValue) Type(ctx context.Context) attr.Type {
	return QueuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"committed_burst_size":              basetypes.Int64Type{},
		"maximum_burst_size":                basetypes.Int64Type{},
		"pfc_off_threshold":                 basetypes.Int64Type{},
		"pfc_on_threshold":                  basetypes.Int64Type{},
		"pfc_pause_frame_priority":          basetypes.Int64Type{},
		"pfc_reserved_share_buffer_percent": basetypes.Int64Type{},
		"queue":                             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
