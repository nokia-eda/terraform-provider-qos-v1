// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_egress_policy

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func EgressPolicyResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^qos\\.eda\\.nokia\\.com/v1$"), ""),
				},
				Default: stringdefault.StaticString("qos.eda.nokia.com/v1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^EgressPolicy$"), ""),
				},
				Default: stringdefault.StaticString("EgressPolicy"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the EgressPolicy",
				MarkdownDescription: "name of the EgressPolicy",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"dot1p_rewrite_policy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dot1p_map": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"drop_probability": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"level": schema.StringAttribute{
														Optional:            true,
														Description:         "A drop probability level within the forwarding class for which a different remarking is desired",
														MarkdownDescription: "A drop probability level within the forwarding class for which a different remarking is desired",
														Validators: []validator.String{
															stringvalidator.OneOf(
																"High",
																"Medium",
																"Low",
															),
														},
													},
													"pcp_value": schema.Int64Attribute{
														Optional:            true,
														Description:         "The PCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general PCP value.",
														MarkdownDescription: "The PCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general PCP value.",
														Validators: []validator.Int64{
															int64validator.Between(0, 7),
														},
													},
												},
												CustomType: DropProbabilityType{
													ObjectType: types.ObjectType{
														AttrTypes: DropProbabilityValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "Drop probability specific overrides within the forwarding class",
											MarkdownDescription: "Drop probability specific overrides within the forwarding class",
										},
										"forwarding_classes": schema.ListAttribute{
											ElementType:         types.StringType,
											Required:            true,
											Description:         "The forwarding class matched to apply the rewrite policy",
											MarkdownDescription: "The forwarding class matched to apply the rewrite policy",
										},
										"pcp_value": schema.Int64Attribute{
											Optional:            true,
											Description:         "The PCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override",
											MarkdownDescription: "The PCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override",
											Validators: []validator.Int64{
												int64validator.Between(0, 7),
											},
										},
									},
									CustomType: Dot1pMapType{
										ObjectType: types.ObjectType{
											AttrTypes: Dot1pMapValue{}.AttributeTypes(ctx),
										},
									},
								},
								Required:            true,
								Description:         "Map of forwarding classes to PCP values",
								MarkdownDescription: "Map of forwarding classes to PCP values",
							},
						},
						CustomType: Dot1pRewritePolicyType{
							ObjectType: types.ObjectType{
								AttrTypes: Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Dot1pRewritePolicy enables the configuration of rewrite policies for Dot1p values. It includes mappings of forwarding classes to Dot1p values, with options for drop probability-specific overrides within each forwarding class.",
						MarkdownDescription: "Dot1pRewritePolicy enables the configuration of rewrite policies for Dot1p values. It includes mappings of forwarding classes to Dot1p values, with options for drop probability-specific overrides within each forwarding class.",
					},
					"dscp_rewrite_policy": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dscp_map": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"drop_probability_1": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"dscp": schema.Int64Attribute{
														Optional:            true,
														Description:         "The DSCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general DSCP value.",
														MarkdownDescription: "The DSCP value to be used for packets associated with the forwarding class and the specific drop probability. This overrides the general DSCP value.",
														Validators: []validator.Int64{
															int64validator.Between(0, 63),
														},
													},
													"level": schema.StringAttribute{
														Optional:            true,
														Description:         "A drop probability level within the forwarding class for which a different remarking is desired.",
														MarkdownDescription: "A drop probability level within the forwarding class for which a different remarking is desired.",
														Validators: []validator.String{
															stringvalidator.OneOf(
																"High",
																"Medium",
																"Low",
															),
														},
													},
												},
												CustomType: DropProbability1Type{
													ObjectType: types.ObjectType{
														AttrTypes: DropProbability1Value{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "A drop probability within the forwarding class for which a different remarking is desired.",
											MarkdownDescription: "A drop probability within the forwarding class for which a different remarking is desired.",
										},
										"dscp": schema.Int64Attribute{
											Optional:            true,
											Description:         "The DSCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override.",
											MarkdownDescription: "The DSCP value to be used for all packets associated with the forwarding class, except those with a drop-probability-specific or profile-specific override.",
											Validators: []validator.Int64{
												int64validator.Between(0, 63),
											},
										},
										"forwarding_classes": schema.ListAttribute{
											ElementType:         types.StringType,
											Required:            true,
											Description:         "The forwarding class matched to apply the rewrite policy.",
											MarkdownDescription: "The forwarding class matched to apply the rewrite policy.",
										},
									},
									CustomType: DscpMapType{
										ObjectType: types.ObjectType{
											AttrTypes: DscpMapValue{}.AttributeTypes(ctx),
										},
									},
								},
								Required:            true,
								Description:         "Map of forwarding classes to DSCP values.",
								MarkdownDescription: "Map of forwarding classes to DSCP values.",
							},
						},
						CustomType: DscpRewritePolicyType{
							ObjectType: types.ObjectType{
								AttrTypes: DscpRewritePolicyValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "DSCPRewritePolicy enables the configuration of rewrite policies for Differentiated Services Code Point (DSCP) values. It includes mappings of forwarding classes to DSCP values, with options for drop probability-specific overrides within each forwarding class.  If a DSCPRewritePolicy is not specified, the DSCP value of the packet is unchanged. If a DSCP policy is specific and ECN is enabled on any of the queues, the DSCP policy will be applied to all ECN capable packets.",
						MarkdownDescription: "DSCPRewritePolicy enables the configuration of rewrite policies for Differentiated Services Code Point (DSCP) values. It includes mappings of forwarding classes to DSCP values, with options for drop probability-specific overrides within each forwarding class.  If a DSCPRewritePolicy is not specified, the DSCP value of the packet is unchanged. If a DSCP policy is specific and ECN is enabled on any of the queues, the DSCP policy will be applied to all ECN capable packets.",
					},
					"forwarding_class_to_queue_mapping": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"forwarding_classes": schema.ListAttribute{
									ElementType:         types.StringType,
									Required:            true,
									Description:         "The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
									MarkdownDescription: "The forwarding classes to which the mapping applies, these are references to ForwardingClass resources.",
									Validators: []validator.List{
										listvalidator.SizeAtLeast(1),
									},
								},
								"queue": schema.StringAttribute{
									Required:            true,
									Description:         "The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
									MarkdownDescription: "The queue to which the forwarding classes are mapped, this is a reference to a Queue resource.",
								},
								"queue_group": schema.StringAttribute{
									Optional:            true,
									Description:         "The queue-group name for queue to forwarding class mapping.",
									MarkdownDescription: "The queue-group name for queue to forwarding class mapping.",
								},
							},
							CustomType: ForwardingClassToQueueMappingType{
								ObjectType: types.ObjectType{
									AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Forwarding class to queue mapping policy.",
						MarkdownDescription: "Forwarding class to queue mapping policy.",
					},
					"pfc_deadlock_avoidance": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"deadlock_avoidance": schema.BoolAttribute{
								Required:            true,
								Description:         "Parameters related to avoid a deadlock related to pfc on outgoing interface",
								MarkdownDescription: "Parameters related to avoid a deadlock related to pfc on outgoing interface",
							},
							"deadlock_detection_timer": schema.Int64Attribute{
								Required:            true,
								Description:         "Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.",
								MarkdownDescription: "Number of milliseconds during which outgoing interface is receiving pfc-pause-frames before triggering recovery-timer.",
							},
							"deadlock_recovery_timer": schema.Int64Attribute{
								Required:            true,
								Description:         "Number of milliseconds during which the pfc-pause-frames will be ignored.",
								MarkdownDescription: "Number of milliseconds during which the pfc-pause-frames will be ignored.",
							},
						},
						CustomType: PfcDeadlockAvoidanceType{
							ObjectType: types.ObjectType{
								AttrTypes: PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Parameters related to avoid a deadlock related to pfc on outgoing interface.",
						MarkdownDescription: "Parameters related to avoid a deadlock related to pfc on outgoing interface.",
					},
					"queue_management": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"queues": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"committed_burst_size": schema.Int64Attribute{
												Optional:            true,
												Description:         "Committed Burst Size.",
												MarkdownDescription: "Committed Burst Size.",
											},
											"maximum_burst_size": schema.Int64Attribute{
												Required:            true,
												Description:         "Maximum amount of shared buffer memory available to the queue in bytes.",
												MarkdownDescription: "Maximum amount of shared buffer memory available to the queue in bytes.",
												Validators: []validator.Int64{
													int64validator.Between(0, 4294967295),
												},
											},
											"pfc_pause_frame_priority": schema.Int64Attribute{
												Optional:            true,
												Description:         "The pfc-priority received in pfc-pause-frame.",
												MarkdownDescription: "The pfc-priority received in pfc-pause-frame.",
											},
											"queue": schema.StringAttribute{
												Required:            true,
												Description:         "Reference to a Queue resource.",
												MarkdownDescription: "Reference to a Queue resource.",
											},
											"scheduler_peak_rate_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "The peak rate percent used by the scheduler for the queue.",
												MarkdownDescription: "The peak rate percent used by the scheduler for the queue.",
												Validators: []validator.Int64{
													int64validator.Between(1, 100),
												},
											},
											"scheduler_priority_level": schema.Int64Attribute{
												Optional:            true,
												Description:         "The priority level at this Port Scheduler Policy.",
												MarkdownDescription: "The priority level at this Port Scheduler Policy.",
												Validators: []validator.Int64{
													int64validator.Between(1, 8),
												},
											},
											"scheduler_weight": schema.Int64Attribute{
												Optional:            true,
												Description:         "The weight factor used for the WRR scheduler. If any of the queues have a configured weight the set of queues will use a WRR scheduler and thus all queues must have a weight configured.  If no weights are set then the queues are scheduled in strict priority from lowest to higher queue ID.",
												MarkdownDescription: "The weight factor used for the WRR scheduler. If any of the queues have a configured weight the set of queues will use a WRR scheduler and thus all queues must have a weight configured.  If no weights are set then the queues are scheduled in strict priority from lowest to higher queue ID.",
												Validators: []validator.Int64{
													int64validator.Between(0, 255),
												},
											},
										},
										CustomType: QueuesType{
											ObjectType: types.ObjectType{
												AttrTypes: QueuesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Required:            true,
									Description:         "List of queues.",
									MarkdownDescription: "List of queues.",
								},
								"slope_policy_weight": schema.Int64Attribute{
									Optional:            true,
									Computed:            true,
									Description:         "The average queue size is calculated using both the previous average and the current queue size: average = (previous average)(1 - 2^(-n)) + (current size)(2^(-n)), where n is a user-configurable weight factor. A higher n gives more importance to the previous average, smoothing peaks and lows in the queue. Lower n makes the average closer to the current queue size. If this leaf is absent, the default value is used.",
									MarkdownDescription: "The average queue size is calculated using both the previous average and the current queue size: average = (previous average)(1 - 2^(-n)) + (current size)(2^(-n)), where n is a user-configurable weight factor. A higher n gives more importance to the previous average, smoothing peaks and lows in the queue. Lower n makes the average closer to the current queue size. If this leaf is absent, the default value is used.",
									Validators: []validator.Int64{
										int64validator.Between(0, 15),
									},
									Default: int64default.StaticInt64(0),
								},
								"wred_slop_policies": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"drop": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "When set to true, and if the ECN field in the packet indicates that the endpoints are not ECN-capable, and the WRED algorithm determines that the packet should be dropped based on the drop probability, the packet will be dropped",
												MarkdownDescription: "When set to true, and if the ECN field in the packet indicates that the endpoints are not ECN-capable, and the WRED algorithm determines that the packet should be dropped based on the drop probability, the packet will be dropped",
												Default:             booldefault.StaticBool(false),
											},
											"drop_probability": schema.StringAttribute{
												Optional: true,
												Computed: true,
												Validators: []validator.String{
													stringvalidator.OneOf(
														"High",
														"Medium",
														"Low",
														"All",
													),
												},
												Default: stringdefault.StaticString("All"),
											},
											"ecn": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "When set to true and the queue length is between the thresholds and the ECN field indicates ECN-capable endpoints, the CE bits are set to 1, and the packet is transmitted based on WRED. If false, such packets are discarded.",
												MarkdownDescription: "When set to true and the queue length is between the thresholds and the ECN field indicates ECN-capable endpoints, the CE bits are set to 1, and the packet is transmitted based on WRED. If false, such packets are discarded.",
												Default:             booldefault.StaticBool(false),
											},
											"max_drop_probability_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.",
												MarkdownDescription: "If the queue depth is between min and max threshold then this the probability with which packets are dropped or marked.",
											},
											"max_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "The maximum threshold parameter for a RED-managed queue in bytes. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold-percent and max-threshold-percent.",
												MarkdownDescription: "The maximum threshold parameter for a RED-managed queue in bytes. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold-percent and max-threshold-percent.",
											},
											"max_threshold_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.",
												MarkdownDescription: "The maximum threshold parameter for a RED-managed queue in percent. When the average queue length exceeds the max value, all packets are dropped (or marked if ECN is enabled). Mutually exclusive with min-threshold and max-threshold.",
											},
											"min_threshold": schema.Int64Attribute{
												Optional:            true,
												Description:         "The mininum threshold parameter for a RED-managed queue in bytes. When the average queue length is less than min, all packets are admitted to the queue. Mututally exclusive with min-threshold-percent and max-threshold-percent.",
												MarkdownDescription: "The mininum threshold parameter for a RED-managed queue in bytes. When the average queue length is less than min, all packets are admitted to the queue. Mututally exclusive with min-threshold-percent and max-threshold-percent.",
											},
											"min_threshold_percent": schema.Int64Attribute{
												Optional:            true,
												Description:         "The mininum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.",
												MarkdownDescription: "The mininum threshold parameter for a RED-managed queue in percent. When the average queue length is less than min, all packets are admitted to the queue. Mutually exclusive with min-threshold and max-threshold.",
											},
											"traffic_type": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "The traffic type to which the WRED slope applies.",
												MarkdownDescription: "The traffic type to which the WRED slope applies.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"Tcp",
														"NonTcp",
														"All",
													),
												},
												Default: stringdefault.StaticString("All"),
											},
										},
										CustomType: WredSlopPoliciesType{
											ObjectType: types.ObjectType{
												AttrTypes: WredSlopPoliciesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "Slope policy to apply to the set of queues.",
									MarkdownDescription: "Slope policy to apply to the set of queues.",
								},
							},
							CustomType: QueueManagementType{
								ObjectType: types.ObjectType{
									AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Queue management policy for egress queues.",
						MarkdownDescription: "Queue management policy for egress queues.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "EgressPolicySpec defines the desired state of EgressPolicy",
				MarkdownDescription: "EgressPolicySpec defines the desired state of EgressPolicy",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "EgressPolicyStatus defines the observed state of EgressPolicy",
				MarkdownDescription: "EgressPolicyStatus defines the observed state of EgressPolicy",
			},
		},
	}
}

type EgressPolicyModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dot1pRewritePolicyAttribute, ok := attributes["dot1p_rewrite_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_rewrite_policy is missing from object`)

		return nil, diags
	}

	dot1pRewritePolicyVal, ok := dot1pRewritePolicyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_rewrite_policy expected to be basetypes.ObjectValue, was: %T`, dot1pRewritePolicyAttribute))
	}

	dscpRewritePolicyAttribute, ok := attributes["dscp_rewrite_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_rewrite_policy is missing from object`)

		return nil, diags
	}

	dscpRewritePolicyVal, ok := dscpRewritePolicyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_rewrite_policy expected to be basetypes.ObjectValue, was: %T`, dscpRewritePolicyAttribute))
	}

	forwardingClassToQueueMappingAttribute, ok := attributes["forwarding_class_to_queue_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class_to_queue_mapping is missing from object`)

		return nil, diags
	}

	forwardingClassToQueueMappingVal, ok := forwardingClassToQueueMappingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class_to_queue_mapping expected to be basetypes.ListValue, was: %T`, forwardingClassToQueueMappingAttribute))
	}

	pfcDeadlockAvoidanceAttribute, ok := attributes["pfc_deadlock_avoidance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_avoidance is missing from object`)

		return nil, diags
	}

	pfcDeadlockAvoidanceVal, ok := pfcDeadlockAvoidanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_avoidance expected to be basetypes.ObjectValue, was: %T`, pfcDeadlockAvoidanceAttribute))
	}

	queueManagementAttribute, ok := attributes["queue_management"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_management is missing from object`)

		return nil, diags
	}

	queueManagementVal, ok := queueManagementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_management expected to be basetypes.ListValue, was: %T`, queueManagementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Dot1pRewritePolicy:            dot1pRewritePolicyVal,
		DscpRewritePolicy:             dscpRewritePolicyVal,
		ForwardingClassToQueueMapping: forwardingClassToQueueMappingVal,
		PfcDeadlockAvoidance:          pfcDeadlockAvoidanceVal,
		QueueManagement:               queueManagementVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	dot1pRewritePolicyAttribute, ok := attributes["dot1p_rewrite_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_rewrite_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	dot1pRewritePolicyVal, ok := dot1pRewritePolicyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_rewrite_policy expected to be basetypes.ObjectValue, was: %T`, dot1pRewritePolicyAttribute))
	}

	dscpRewritePolicyAttribute, ok := attributes["dscp_rewrite_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_rewrite_policy is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	dscpRewritePolicyVal, ok := dscpRewritePolicyAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_rewrite_policy expected to be basetypes.ObjectValue, was: %T`, dscpRewritePolicyAttribute))
	}

	forwardingClassToQueueMappingAttribute, ok := attributes["forwarding_class_to_queue_mapping"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_class_to_queue_mapping is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	forwardingClassToQueueMappingVal, ok := forwardingClassToQueueMappingAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_class_to_queue_mapping expected to be basetypes.ListValue, was: %T`, forwardingClassToQueueMappingAttribute))
	}

	pfcDeadlockAvoidanceAttribute, ok := attributes["pfc_deadlock_avoidance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_deadlock_avoidance is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	pfcDeadlockAvoidanceVal, ok := pfcDeadlockAvoidanceAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_deadlock_avoidance expected to be basetypes.ObjectValue, was: %T`, pfcDeadlockAvoidanceAttribute))
	}

	queueManagementAttribute, ok := attributes["queue_management"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_management is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	queueManagementVal, ok := queueManagementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_management expected to be basetypes.ListValue, was: %T`, queueManagementAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Dot1pRewritePolicy:            dot1pRewritePolicyVal,
		DscpRewritePolicy:             dscpRewritePolicyVal,
		ForwardingClassToQueueMapping: forwardingClassToQueueMappingVal,
		PfcDeadlockAvoidance:          pfcDeadlockAvoidanceVal,
		QueueManagement:               queueManagementVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Dot1pRewritePolicy            basetypes.ObjectValue `tfsdk:"dot1p_rewrite_policy"`
	DscpRewritePolicy             basetypes.ObjectValue `tfsdk:"dscp_rewrite_policy"`
	ForwardingClassToQueueMapping basetypes.ListValue   `tfsdk:"forwarding_class_to_queue_mapping"`
	PfcDeadlockAvoidance          basetypes.ObjectValue `tfsdk:"pfc_deadlock_avoidance"`
	QueueManagement               basetypes.ListValue   `tfsdk:"queue_management"`
	state                         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dot1p_rewrite_policy"] = basetypes.ObjectType{
		AttrTypes: Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["dscp_rewrite_policy"] = basetypes.ObjectType{
		AttrTypes: DscpRewritePolicyValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["forwarding_class_to_queue_mapping"] = basetypes.ListType{
		ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["pfc_deadlock_avoidance"] = basetypes.ObjectType{
		AttrTypes: PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["queue_management"] = basetypes.ListType{
		ElemType: QueueManagementValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Dot1pRewritePolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dot1p_rewrite_policy"] = val

		val, err = v.DscpRewritePolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp_rewrite_policy"] = val

		val, err = v.ForwardingClassToQueueMapping.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_class_to_queue_mapping"] = val

		val, err = v.PfcDeadlockAvoidance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_deadlock_avoidance"] = val

		val, err = v.QueueManagement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue_management"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dot1pRewritePolicy basetypes.ObjectValue

	if v.Dot1pRewritePolicy.IsNull() {
		dot1pRewritePolicy = types.ObjectNull(
			Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
		)
	}

	if v.Dot1pRewritePolicy.IsUnknown() {
		dot1pRewritePolicy = types.ObjectUnknown(
			Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Dot1pRewritePolicy.IsNull() && !v.Dot1pRewritePolicy.IsUnknown() {
		dot1pRewritePolicy = types.ObjectValueMust(
			Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
			v.Dot1pRewritePolicy.Attributes(),
		)
	}

	var dscpRewritePolicy basetypes.ObjectValue

	if v.DscpRewritePolicy.IsNull() {
		dscpRewritePolicy = types.ObjectNull(
			DscpRewritePolicyValue{}.AttributeTypes(ctx),
		)
	}

	if v.DscpRewritePolicy.IsUnknown() {
		dscpRewritePolicy = types.ObjectUnknown(
			DscpRewritePolicyValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DscpRewritePolicy.IsNull() && !v.DscpRewritePolicy.IsUnknown() {
		dscpRewritePolicy = types.ObjectValueMust(
			DscpRewritePolicyValue{}.AttributeTypes(ctx),
			v.DscpRewritePolicy.Attributes(),
		)
	}

	forwardingClassToQueueMapping := types.ListValueMust(
		ForwardingClassToQueueMappingType{
			basetypes.ObjectType{
				AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
			},
		},
		v.ForwardingClassToQueueMapping.Elements(),
	)

	if v.ForwardingClassToQueueMapping.IsNull() {
		forwardingClassToQueueMapping = types.ListNull(
			ForwardingClassToQueueMappingType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.ForwardingClassToQueueMapping.IsUnknown() {
		forwardingClassToQueueMapping = types.ListUnknown(
			ForwardingClassToQueueMappingType{
				basetypes.ObjectType{
					AttrTypes: ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var pfcDeadlockAvoidance basetypes.ObjectValue

	if v.PfcDeadlockAvoidance.IsNull() {
		pfcDeadlockAvoidance = types.ObjectNull(
			PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
		)
	}

	if v.PfcDeadlockAvoidance.IsUnknown() {
		pfcDeadlockAvoidance = types.ObjectUnknown(
			PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PfcDeadlockAvoidance.IsNull() && !v.PfcDeadlockAvoidance.IsUnknown() {
		pfcDeadlockAvoidance = types.ObjectValueMust(
			PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
			v.PfcDeadlockAvoidance.Attributes(),
		)
	}

	queueManagement := types.ListValueMust(
		QueueManagementType{
			basetypes.ObjectType{
				AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
			},
		},
		v.QueueManagement.Elements(),
	)

	if v.QueueManagement.IsNull() {
		queueManagement = types.ListNull(
			QueueManagementType{
				basetypes.ObjectType{
					AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.QueueManagement.IsUnknown() {
		queueManagement = types.ListUnknown(
			QueueManagementType{
				basetypes.ObjectType{
					AttrTypes: QueueManagementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"dot1p_rewrite_policy": basetypes.ObjectType{
			AttrTypes: Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
		},
		"dscp_rewrite_policy": basetypes.ObjectType{
			AttrTypes: DscpRewritePolicyValue{}.AttributeTypes(ctx),
		},
		"forwarding_class_to_queue_mapping": basetypes.ListType{
			ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
		},
		"pfc_deadlock_avoidance": basetypes.ObjectType{
			AttrTypes: PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
		},
		"queue_management": basetypes.ListType{
			ElemType: QueueManagementValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dot1p_rewrite_policy":              dot1pRewritePolicy,
			"dscp_rewrite_policy":               dscpRewritePolicy,
			"forwarding_class_to_queue_mapping": forwardingClassToQueueMapping,
			"pfc_deadlock_avoidance":            pfcDeadlockAvoidance,
			"queue_management":                  queueManagement,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dot1pRewritePolicy.Equal(other.Dot1pRewritePolicy) {
		return false
	}

	if !v.DscpRewritePolicy.Equal(other.DscpRewritePolicy) {
		return false
	}

	if !v.ForwardingClassToQueueMapping.Equal(other.ForwardingClassToQueueMapping) {
		return false
	}

	if !v.PfcDeadlockAvoidance.Equal(other.PfcDeadlockAvoidance) {
		return false
	}

	if !v.QueueManagement.Equal(other.QueueManagement) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dot1p_rewrite_policy": basetypes.ObjectType{
			AttrTypes: Dot1pRewritePolicyValue{}.AttributeTypes(ctx),
		},
		"dscp_rewrite_policy": basetypes.ObjectType{
			AttrTypes: DscpRewritePolicyValue{}.AttributeTypes(ctx),
		},
		"forwarding_class_to_queue_mapping": basetypes.ListType{
			ElemType: ForwardingClassToQueueMappingValue{}.Type(ctx),
		},
		"pfc_deadlock_avoidance": basetypes.ObjectType{
			AttrTypes: PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx),
		},
		"queue_management": basetypes.ListType{
			ElemType: QueueManagementValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Dot1pRewritePolicyType{}

type Dot1pRewritePolicyType struct {
	basetypes.ObjectType
}

func (t Dot1pRewritePolicyType) Equal(o attr.Type) bool {
	other, ok := o.(Dot1pRewritePolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Dot1pRewritePolicyType) String() string {
	return "Dot1pRewritePolicyType"
}

func (t Dot1pRewritePolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dot1pMapAttribute, ok := attributes["dot1p_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_map is missing from object`)

		return nil, diags
	}

	dot1pMapVal, ok := dot1pMapAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_map expected to be basetypes.ListValue, was: %T`, dot1pMapAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Dot1pRewritePolicyValue{
		Dot1pMap: dot1pMapVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDot1pRewritePolicyValueNull() Dot1pRewritePolicyValue {
	return Dot1pRewritePolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewDot1pRewritePolicyValueUnknown() Dot1pRewritePolicyValue {
	return Dot1pRewritePolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDot1pRewritePolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Dot1pRewritePolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Dot1pRewritePolicyValue Attribute Value",
				"While creating a Dot1pRewritePolicyValue value, a missing attribute value was detected. "+
					"A Dot1pRewritePolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pRewritePolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Dot1pRewritePolicyValue Attribute Type",
				"While creating a Dot1pRewritePolicyValue value, an invalid attribute value was detected. "+
					"A Dot1pRewritePolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pRewritePolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Dot1pRewritePolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Dot1pRewritePolicyValue Attribute Value",
				"While creating a Dot1pRewritePolicyValue value, an extra attribute value was detected. "+
					"A Dot1pRewritePolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Dot1pRewritePolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDot1pRewritePolicyValueUnknown(), diags
	}

	dot1pMapAttribute, ok := attributes["dot1p_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dot1p_map is missing from object`)

		return NewDot1pRewritePolicyValueUnknown(), diags
	}

	dot1pMapVal, ok := dot1pMapAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dot1p_map expected to be basetypes.ListValue, was: %T`, dot1pMapAttribute))
	}

	if diags.HasError() {
		return NewDot1pRewritePolicyValueUnknown(), diags
	}

	return Dot1pRewritePolicyValue{
		Dot1pMap: dot1pMapVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDot1pRewritePolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Dot1pRewritePolicyValue {
	object, diags := NewDot1pRewritePolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDot1pRewritePolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Dot1pRewritePolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDot1pRewritePolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDot1pRewritePolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDot1pRewritePolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDot1pRewritePolicyValueMust(Dot1pRewritePolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Dot1pRewritePolicyType) ValueType(ctx context.Context) attr.Value {
	return Dot1pRewritePolicyValue{}
}

var _ basetypes.ObjectValuable = Dot1pRewritePolicyValue{}

type Dot1pRewritePolicyValue struct {
	Dot1pMap basetypes.ListValue `tfsdk:"dot1p_map"`
	state    attr.ValueState
}

func (v Dot1pRewritePolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["dot1p_map"] = basetypes.ListType{
		ElemType: Dot1pMapValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Dot1pMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dot1p_map"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Dot1pRewritePolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Dot1pRewritePolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Dot1pRewritePolicyValue) String() string {
	return "Dot1pRewritePolicyValue"
}

func (v Dot1pRewritePolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dot1pMap := types.ListValueMust(
		Dot1pMapType{
			basetypes.ObjectType{
				AttrTypes: Dot1pMapValue{}.AttributeTypes(ctx),
			},
		},
		v.Dot1pMap.Elements(),
	)

	if v.Dot1pMap.IsNull() {
		dot1pMap = types.ListNull(
			Dot1pMapType{
				basetypes.ObjectType{
					AttrTypes: Dot1pMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Dot1pMap.IsUnknown() {
		dot1pMap = types.ListUnknown(
			Dot1pMapType{
				basetypes.ObjectType{
					AttrTypes: Dot1pMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"dot1p_map": basetypes.ListType{
			ElemType: Dot1pMapValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dot1p_map": dot1pMap,
		})

	return objVal, diags
}

func (v Dot1pRewritePolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(Dot1pRewritePolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dot1pMap.Equal(other.Dot1pMap) {
		return false
	}

	return true
}

func (v Dot1pRewritePolicyValue) Type(ctx context.Context) attr.Type {
	return Dot1pRewritePolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Dot1pRewritePolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dot1p_map": basetypes.ListType{
			ElemType: Dot1pMapValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Dot1pMapType{}

type Dot1pMapType struct {
	basetypes.ObjectType
}

func (t Dot1pMapType) Equal(o attr.Type) bool {
	other, ok := o.(Dot1pMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Dot1pMapType) String() string {
	return "Dot1pMapType"
}

func (t Dot1pMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbabilityAttribute, ok := attributes["drop_probability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability is missing from object`)

		return nil, diags
	}

	dropProbabilityVal, ok := dropProbabilityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability expected to be basetypes.ListValue, was: %T`, dropProbabilityAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	pcpValueAttribute, ok := attributes["pcp_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_value is missing from object`)

		return nil, diags
	}

	pcpValueVal, ok := pcpValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_value expected to be basetypes.Int64Value, was: %T`, pcpValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Dot1pMapValue{
		DropProbability:   dropProbabilityVal,
		ForwardingClasses: forwardingClassesVal,
		PcpValue:          pcpValueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDot1pMapValueNull() Dot1pMapValue {
	return Dot1pMapValue{
		state: attr.ValueStateNull,
	}
}

func NewDot1pMapValueUnknown() Dot1pMapValue {
	return Dot1pMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDot1pMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Dot1pMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Dot1pMapValue Attribute Value",
				"While creating a Dot1pMapValue value, a missing attribute value was detected. "+
					"A Dot1pMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Dot1pMapValue Attribute Type",
				"While creating a Dot1pMapValue value, an invalid attribute value was detected. "+
					"A Dot1pMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Dot1pMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Dot1pMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Dot1pMapValue Attribute Value",
				"While creating a Dot1pMapValue value, an extra attribute value was detected. "+
					"A Dot1pMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Dot1pMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDot1pMapValueUnknown(), diags
	}

	dropProbabilityAttribute, ok := attributes["drop_probability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability is missing from object`)

		return NewDot1pMapValueUnknown(), diags
	}

	dropProbabilityVal, ok := dropProbabilityAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability expected to be basetypes.ListValue, was: %T`, dropProbabilityAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewDot1pMapValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	pcpValueAttribute, ok := attributes["pcp_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_value is missing from object`)

		return NewDot1pMapValueUnknown(), diags
	}

	pcpValueVal, ok := pcpValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_value expected to be basetypes.Int64Value, was: %T`, pcpValueAttribute))
	}

	if diags.HasError() {
		return NewDot1pMapValueUnknown(), diags
	}

	return Dot1pMapValue{
		DropProbability:   dropProbabilityVal,
		ForwardingClasses: forwardingClassesVal,
		PcpValue:          pcpValueVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDot1pMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Dot1pMapValue {
	object, diags := NewDot1pMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDot1pMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Dot1pMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDot1pMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDot1pMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDot1pMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDot1pMapValueMust(Dot1pMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Dot1pMapType) ValueType(ctx context.Context) attr.Value {
	return Dot1pMapValue{}
}

var _ basetypes.ObjectValuable = Dot1pMapValue{}

type Dot1pMapValue struct {
	DropProbability   basetypes.ListValue  `tfsdk:"drop_probability"`
	ForwardingClasses basetypes.ListValue  `tfsdk:"forwarding_classes"`
	PcpValue          basetypes.Int64Value `tfsdk:"pcp_value"`
	state             attr.ValueState
}

func (v Dot1pMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability"] = basetypes.ListType{
		ElemType: DropProbabilityValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["pcp_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DropProbability.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability"] = val

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		val, err = v.PcpValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pcp_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Dot1pMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Dot1pMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Dot1pMapValue) String() string {
	return "Dot1pMapValue"
}

func (v Dot1pMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dropProbability := types.ListValueMust(
		DropProbabilityType{
			basetypes.ObjectType{
				AttrTypes: DropProbabilityValue{}.AttributeTypes(ctx),
			},
		},
		v.DropProbability.Elements(),
	)

	if v.DropProbability.IsNull() {
		dropProbability = types.ListNull(
			DropProbabilityType{
				basetypes.ObjectType{
					AttrTypes: DropProbabilityValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DropProbability.IsUnknown() {
		dropProbability = types.ListUnknown(
			DropProbabilityType{
				basetypes.ObjectType{
					AttrTypes: DropProbabilityValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var forwardingClassesVal basetypes.ListValue
	switch {
	case v.ForwardingClasses.IsUnknown():
		forwardingClassesVal = types.ListUnknown(types.StringType)
	case v.ForwardingClasses.IsNull():
		forwardingClassesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingClassesVal, d = types.ListValue(types.StringType, v.ForwardingClasses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"drop_probability": basetypes.ListType{
				ElemType: DropProbabilityValue{}.Type(ctx),
			},
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"pcp_value": basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"drop_probability": basetypes.ListType{
			ElemType: DropProbabilityValue{}.Type(ctx),
		},
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pcp_value": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability":   dropProbability,
			"forwarding_classes": forwardingClassesVal,
			"pcp_value":          v.PcpValue,
		})

	return objVal, diags
}

func (v Dot1pMapValue) Equal(o attr.Value) bool {
	other, ok := o.(Dot1pMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbability.Equal(other.DropProbability) {
		return false
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	if !v.PcpValue.Equal(other.PcpValue) {
		return false
	}

	return true
}

func (v Dot1pMapValue) Type(ctx context.Context) attr.Type {
	return Dot1pMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Dot1pMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability": basetypes.ListType{
			ElemType: DropProbabilityValue{}.Type(ctx),
		},
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"pcp_value": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DropProbabilityType{}

type DropProbabilityType struct {
	basetypes.ObjectType
}

func (t DropProbabilityType) Equal(o attr.Type) bool {
	other, ok := o.(DropProbabilityType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DropProbabilityType) String() string {
	return "DropProbabilityType"
}

func (t DropProbabilityType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return nil, diags
	}

	levelVal, ok := levelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.StringValue, was: %T`, levelAttribute))
	}

	pcpValueAttribute, ok := attributes["pcp_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_value is missing from object`)

		return nil, diags
	}

	pcpValueVal, ok := pcpValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_value expected to be basetypes.Int64Value, was: %T`, pcpValueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DropProbabilityValue{
		Level:    levelVal,
		PcpValue: pcpValueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDropProbabilityValueNull() DropProbabilityValue {
	return DropProbabilityValue{
		state: attr.ValueStateNull,
	}
}

func NewDropProbabilityValueUnknown() DropProbabilityValue {
	return DropProbabilityValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDropProbabilityValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DropProbabilityValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DropProbabilityValue Attribute Value",
				"While creating a DropProbabilityValue value, a missing attribute value was detected. "+
					"A DropProbabilityValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropProbabilityValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DropProbabilityValue Attribute Type",
				"While creating a DropProbabilityValue value, an invalid attribute value was detected. "+
					"A DropProbabilityValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropProbabilityValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DropProbabilityValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DropProbabilityValue Attribute Value",
				"While creating a DropProbabilityValue value, an extra attribute value was detected. "+
					"A DropProbabilityValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DropProbabilityValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDropProbabilityValueUnknown(), diags
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return NewDropProbabilityValueUnknown(), diags
	}

	levelVal, ok := levelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.StringValue, was: %T`, levelAttribute))
	}

	pcpValueAttribute, ok := attributes["pcp_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pcp_value is missing from object`)

		return NewDropProbabilityValueUnknown(), diags
	}

	pcpValueVal, ok := pcpValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pcp_value expected to be basetypes.Int64Value, was: %T`, pcpValueAttribute))
	}

	if diags.HasError() {
		return NewDropProbabilityValueUnknown(), diags
	}

	return DropProbabilityValue{
		Level:    levelVal,
		PcpValue: pcpValueVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewDropProbabilityValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DropProbabilityValue {
	object, diags := NewDropProbabilityValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDropProbabilityValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DropProbabilityType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDropProbabilityValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDropProbabilityValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDropProbabilityValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDropProbabilityValueMust(DropProbabilityValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DropProbabilityType) ValueType(ctx context.Context) attr.Value {
	return DropProbabilityValue{}
}

var _ basetypes.ObjectValuable = DropProbabilityValue{}

type DropProbabilityValue struct {
	Level    basetypes.StringValue `tfsdk:"level"`
	PcpValue basetypes.Int64Value  `tfsdk:"pcp_value"`
	state    attr.ValueState
}

func (v DropProbabilityValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["level"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["pcp_value"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Level.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["level"] = val

		val, err = v.PcpValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pcp_value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DropProbabilityValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DropProbabilityValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DropProbabilityValue) String() string {
	return "DropProbabilityValue"
}

func (v DropProbabilityValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"level":     basetypes.StringType{},
		"pcp_value": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"level":     v.Level,
			"pcp_value": v.PcpValue,
		})

	return objVal, diags
}

func (v DropProbabilityValue) Equal(o attr.Value) bool {
	other, ok := o.(DropProbabilityValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Level.Equal(other.Level) {
		return false
	}

	if !v.PcpValue.Equal(other.PcpValue) {
		return false
	}

	return true
}

func (v DropProbabilityValue) Type(ctx context.Context) attr.Type {
	return DropProbabilityType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DropProbabilityValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"level":     basetypes.StringType{},
		"pcp_value": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DscpRewritePolicyType{}

type DscpRewritePolicyType struct {
	basetypes.ObjectType
}

func (t DscpRewritePolicyType) Equal(o attr.Type) bool {
	other, ok := o.(DscpRewritePolicyType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DscpRewritePolicyType) String() string {
	return "DscpRewritePolicyType"
}

func (t DscpRewritePolicyType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpMapAttribute, ok := attributes["dscp_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_map is missing from object`)

		return nil, diags
	}

	dscpMapVal, ok := dscpMapAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_map expected to be basetypes.ListValue, was: %T`, dscpMapAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DscpRewritePolicyValue{
		DscpMap: dscpMapVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDscpRewritePolicyValueNull() DscpRewritePolicyValue {
	return DscpRewritePolicyValue{
		state: attr.ValueStateNull,
	}
}

func NewDscpRewritePolicyValueUnknown() DscpRewritePolicyValue {
	return DscpRewritePolicyValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDscpRewritePolicyValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DscpRewritePolicyValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DscpRewritePolicyValue Attribute Value",
				"While creating a DscpRewritePolicyValue value, a missing attribute value was detected. "+
					"A DscpRewritePolicyValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpRewritePolicyValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DscpRewritePolicyValue Attribute Type",
				"While creating a DscpRewritePolicyValue value, an invalid attribute value was detected. "+
					"A DscpRewritePolicyValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpRewritePolicyValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DscpRewritePolicyValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DscpRewritePolicyValue Attribute Value",
				"While creating a DscpRewritePolicyValue value, an extra attribute value was detected. "+
					"A DscpRewritePolicyValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DscpRewritePolicyValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDscpRewritePolicyValueUnknown(), diags
	}

	dscpMapAttribute, ok := attributes["dscp_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp_map is missing from object`)

		return NewDscpRewritePolicyValueUnknown(), diags
	}

	dscpMapVal, ok := dscpMapAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp_map expected to be basetypes.ListValue, was: %T`, dscpMapAttribute))
	}

	if diags.HasError() {
		return NewDscpRewritePolicyValueUnknown(), diags
	}

	return DscpRewritePolicyValue{
		DscpMap: dscpMapVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewDscpRewritePolicyValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DscpRewritePolicyValue {
	object, diags := NewDscpRewritePolicyValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDscpRewritePolicyValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DscpRewritePolicyType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDscpRewritePolicyValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDscpRewritePolicyValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDscpRewritePolicyValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDscpRewritePolicyValueMust(DscpRewritePolicyValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DscpRewritePolicyType) ValueType(ctx context.Context) attr.Value {
	return DscpRewritePolicyValue{}
}

var _ basetypes.ObjectValuable = DscpRewritePolicyValue{}

type DscpRewritePolicyValue struct {
	DscpMap basetypes.ListValue `tfsdk:"dscp_map"`
	state   attr.ValueState
}

func (v DscpRewritePolicyValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["dscp_map"] = basetypes.ListType{
		ElemType: DscpMapValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DscpMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp_map"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DscpRewritePolicyValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DscpRewritePolicyValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DscpRewritePolicyValue) String() string {
	return "DscpRewritePolicyValue"
}

func (v DscpRewritePolicyValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dscpMap := types.ListValueMust(
		DscpMapType{
			basetypes.ObjectType{
				AttrTypes: DscpMapValue{}.AttributeTypes(ctx),
			},
		},
		v.DscpMap.Elements(),
	)

	if v.DscpMap.IsNull() {
		dscpMap = types.ListNull(
			DscpMapType{
				basetypes.ObjectType{
					AttrTypes: DscpMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DscpMap.IsUnknown() {
		dscpMap = types.ListUnknown(
			DscpMapType{
				basetypes.ObjectType{
					AttrTypes: DscpMapValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"dscp_map": basetypes.ListType{
			ElemType: DscpMapValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp_map": dscpMap,
		})

	return objVal, diags
}

func (v DscpRewritePolicyValue) Equal(o attr.Value) bool {
	other, ok := o.(DscpRewritePolicyValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DscpMap.Equal(other.DscpMap) {
		return false
	}

	return true
}

func (v DscpRewritePolicyValue) Type(ctx context.Context) attr.Type {
	return DscpRewritePolicyType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DscpRewritePolicyValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp_map": basetypes.ListType{
			ElemType: DscpMapValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DscpMapType{}

type DscpMapType struct {
	basetypes.ObjectType
}

func (t DscpMapType) Equal(o attr.Type) bool {
	other, ok := o.(DscpMapType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DscpMapType) String() string {
	return "DscpMapType"
}

func (t DscpMapType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropProbability1Attribute, ok := attributes["drop_probability_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_1 is missing from object`)

		return nil, diags
	}

	dropProbability1Val, ok := dropProbability1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_1 expected to be basetypes.ListValue, was: %T`, dropProbability1Attribute))
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DscpMapValue{
		DropProbability1:  dropProbability1Val,
		Dscp:              dscpVal,
		ForwardingClasses: forwardingClassesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDscpMapValueNull() DscpMapValue {
	return DscpMapValue{
		state: attr.ValueStateNull,
	}
}

func NewDscpMapValueUnknown() DscpMapValue {
	return DscpMapValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDscpMapValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DscpMapValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DscpMapValue Attribute Value",
				"While creating a DscpMapValue value, a missing attribute value was detected. "+
					"A DscpMapValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpMapValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DscpMapValue Attribute Type",
				"While creating a DscpMapValue value, an invalid attribute value was detected. "+
					"A DscpMapValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DscpMapValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DscpMapValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DscpMapValue Attribute Value",
				"While creating a DscpMapValue value, an extra attribute value was detected. "+
					"A DscpMapValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DscpMapValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDscpMapValueUnknown(), diags
	}

	dropProbability1Attribute, ok := attributes["drop_probability_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability_1 is missing from object`)

		return NewDscpMapValueUnknown(), diags
	}

	dropProbability1Val, ok := dropProbability1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability_1 expected to be basetypes.ListValue, was: %T`, dropProbability1Attribute))
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewDscpMapValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewDscpMapValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	if diags.HasError() {
		return NewDscpMapValueUnknown(), diags
	}

	return DscpMapValue{
		DropProbability1:  dropProbability1Val,
		Dscp:              dscpVal,
		ForwardingClasses: forwardingClassesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDscpMapValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DscpMapValue {
	object, diags := NewDscpMapValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDscpMapValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DscpMapType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDscpMapValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDscpMapValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDscpMapValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDscpMapValueMust(DscpMapValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DscpMapType) ValueType(ctx context.Context) attr.Value {
	return DscpMapValue{}
}

var _ basetypes.ObjectValuable = DscpMapValue{}

type DscpMapValue struct {
	DropProbability1  basetypes.ListValue  `tfsdk:"drop_probability_1"`
	Dscp              basetypes.Int64Value `tfsdk:"dscp"`
	ForwardingClasses basetypes.ListValue  `tfsdk:"forwarding_classes"`
	state             attr.ValueState
}

func (v DscpMapValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["drop_probability_1"] = basetypes.ListType{
		ElemType: DropProbability1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DropProbability1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability_1"] = val

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DscpMapValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DscpMapValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DscpMapValue) String() string {
	return "DscpMapValue"
}

func (v DscpMapValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	dropProbability1 := types.ListValueMust(
		DropProbability1Type{
			basetypes.ObjectType{
				AttrTypes: DropProbability1Value{}.AttributeTypes(ctx),
			},
		},
		v.DropProbability1.Elements(),
	)

	if v.DropProbability1.IsNull() {
		dropProbability1 = types.ListNull(
			DropProbability1Type{
				basetypes.ObjectType{
					AttrTypes: DropProbability1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DropProbability1.IsUnknown() {
		dropProbability1 = types.ListUnknown(
			DropProbability1Type{
				basetypes.ObjectType{
					AttrTypes: DropProbability1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var forwardingClassesVal basetypes.ListValue
	switch {
	case v.ForwardingClasses.IsUnknown():
		forwardingClassesVal = types.ListUnknown(types.StringType)
	case v.ForwardingClasses.IsNull():
		forwardingClassesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingClassesVal, d = types.ListValue(types.StringType, v.ForwardingClasses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"drop_probability_1": basetypes.ListType{
				ElemType: DropProbability1Value{}.Type(ctx),
			},
			"dscp": basetypes.Int64Type{},
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"drop_probability_1": basetypes.ListType{
			ElemType: DropProbability1Value{}.Type(ctx),
		},
		"dscp": basetypes.Int64Type{},
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop_probability_1": dropProbability1,
			"dscp":               v.Dscp,
			"forwarding_classes": forwardingClassesVal,
		})

	return objVal, diags
}

func (v DscpMapValue) Equal(o attr.Value) bool {
	other, ok := o.(DscpMapValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DropProbability1.Equal(other.DropProbability1) {
		return false
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	return true
}

func (v DscpMapValue) Type(ctx context.Context) attr.Type {
	return DscpMapType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DscpMapValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop_probability_1": basetypes.ListType{
			ElemType: DropProbability1Value{}.Type(ctx),
		},
		"dscp": basetypes.Int64Type{},
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = DropProbability1Type{}

type DropProbability1Type struct {
	basetypes.ObjectType
}

func (t DropProbability1Type) Equal(o attr.Type) bool {
	other, ok := o.(DropProbability1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DropProbability1Type) String() string {
	return "DropProbability1Type"
}

func (t DropProbability1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return nil, diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return nil, diags
	}

	levelVal, ok := levelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.StringValue, was: %T`, levelAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DropProbability1Value{
		Dscp:  dscpVal,
		Level: levelVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDropProbability1ValueNull() DropProbability1Value {
	return DropProbability1Value{
		state: attr.ValueStateNull,
	}
}

func NewDropProbability1ValueUnknown() DropProbability1Value {
	return DropProbability1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewDropProbability1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DropProbability1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DropProbability1Value Attribute Value",
				"While creating a DropProbability1Value value, a missing attribute value was detected. "+
					"A DropProbability1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropProbability1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DropProbability1Value Attribute Type",
				"While creating a DropProbability1Value value, an invalid attribute value was detected. "+
					"A DropProbability1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DropProbability1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DropProbability1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DropProbability1Value Attribute Value",
				"While creating a DropProbability1Value value, an extra attribute value was detected. "+
					"A DropProbability1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DropProbability1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDropProbability1ValueUnknown(), diags
	}

	dscpAttribute, ok := attributes["dscp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dscp is missing from object`)

		return NewDropProbability1ValueUnknown(), diags
	}

	dscpVal, ok := dscpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dscp expected to be basetypes.Int64Value, was: %T`, dscpAttribute))
	}

	levelAttribute, ok := attributes["level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`level is missing from object`)

		return NewDropProbability1ValueUnknown(), diags
	}

	levelVal, ok := levelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`level expected to be basetypes.StringValue, was: %T`, levelAttribute))
	}

	if diags.HasError() {
		return NewDropProbability1ValueUnknown(), diags
	}

	return DropProbability1Value{
		Dscp:  dscpVal,
		Level: levelVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDropProbability1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DropProbability1Value {
	object, diags := NewDropProbability1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDropProbability1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DropProbability1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDropProbability1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDropProbability1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDropProbability1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDropProbability1ValueMust(DropProbability1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t DropProbability1Type) ValueType(ctx context.Context) attr.Value {
	return DropProbability1Value{}
}

var _ basetypes.ObjectValuable = DropProbability1Value{}

type DropProbability1Value struct {
	Dscp  basetypes.Int64Value  `tfsdk:"dscp"`
	Level basetypes.StringValue `tfsdk:"level"`
	state attr.ValueState
}

func (v DropProbability1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["dscp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["level"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Dscp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dscp"] = val

		val, err = v.Level.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["level"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DropProbability1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DropProbability1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DropProbability1Value) String() string {
	return "DropProbability1Value"
}

func (v DropProbability1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dscp":  basetypes.Int64Type{},
		"level": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dscp":  v.Dscp,
			"level": v.Level,
		})

	return objVal, diags
}

func (v DropProbability1Value) Equal(o attr.Value) bool {
	other, ok := o.(DropProbability1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dscp.Equal(other.Dscp) {
		return false
	}

	if !v.Level.Equal(other.Level) {
		return false
	}

	return true
}

func (v DropProbability1Value) Type(ctx context.Context) attr.Type {
	return DropProbability1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DropProbability1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dscp":  basetypes.Int64Type{},
		"level": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ForwardingClassToQueueMappingType{}

type ForwardingClassToQueueMappingType struct {
	basetypes.ObjectType
}

func (t ForwardingClassToQueueMappingType) Equal(o attr.Type) bool {
	other, ok := o.(ForwardingClassToQueueMappingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ForwardingClassToQueueMappingType) String() string {
	return "ForwardingClassToQueueMappingType"
}

func (t ForwardingClassToQueueMappingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return nil, diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return nil, diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	queueGroupAttribute, ok := attributes["queue_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_group is missing from object`)

		return nil, diags
	}

	queueGroupVal, ok := queueGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_group expected to be basetypes.StringValue, was: %T`, queueGroupAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ForwardingClassToQueueMappingValue{
		ForwardingClasses: forwardingClassesVal,
		Queue:             queueVal,
		QueueGroup:        queueGroupVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassToQueueMappingValueNull() ForwardingClassToQueueMappingValue {
	return ForwardingClassToQueueMappingValue{
		state: attr.ValueStateNull,
	}
}

func NewForwardingClassToQueueMappingValueUnknown() ForwardingClassToQueueMappingValue {
	return ForwardingClassToQueueMappingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewForwardingClassToQueueMappingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ForwardingClassToQueueMappingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ForwardingClassToQueueMappingValue Attribute Value",
				"While creating a ForwardingClassToQueueMappingValue value, a missing attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ForwardingClassToQueueMappingValue Attribute Type",
				"While creating a ForwardingClassToQueueMappingValue value, an invalid attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ForwardingClassToQueueMappingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ForwardingClassToQueueMappingValue Attribute Value",
				"While creating a ForwardingClassToQueueMappingValue value, an extra attribute value was detected. "+
					"A ForwardingClassToQueueMappingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ForwardingClassToQueueMappingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	forwardingClassesAttribute, ok := attributes["forwarding_classes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`forwarding_classes is missing from object`)

		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	forwardingClassesVal, ok := forwardingClassesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`forwarding_classes expected to be basetypes.ListValue, was: %T`, forwardingClassesAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	queueGroupAttribute, ok := attributes["queue_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue_group is missing from object`)

		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	queueGroupVal, ok := queueGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue_group expected to be basetypes.StringValue, was: %T`, queueGroupAttribute))
	}

	if diags.HasError() {
		return NewForwardingClassToQueueMappingValueUnknown(), diags
	}

	return ForwardingClassToQueueMappingValue{
		ForwardingClasses: forwardingClassesVal,
		Queue:             queueVal,
		QueueGroup:        queueGroupVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewForwardingClassToQueueMappingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ForwardingClassToQueueMappingValue {
	object, diags := NewForwardingClassToQueueMappingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewForwardingClassToQueueMappingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ForwardingClassToQueueMappingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewForwardingClassToQueueMappingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewForwardingClassToQueueMappingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewForwardingClassToQueueMappingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewForwardingClassToQueueMappingValueMust(ForwardingClassToQueueMappingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ForwardingClassToQueueMappingType) ValueType(ctx context.Context) attr.Value {
	return ForwardingClassToQueueMappingValue{}
}

var _ basetypes.ObjectValuable = ForwardingClassToQueueMappingValue{}

type ForwardingClassToQueueMappingValue struct {
	ForwardingClasses basetypes.ListValue   `tfsdk:"forwarding_classes"`
	Queue             basetypes.StringValue `tfsdk:"queue"`
	QueueGroup        basetypes.StringValue `tfsdk:"queue_group"`
	state             attr.ValueState
}

func (v ForwardingClassToQueueMappingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["forwarding_classes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["queue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["queue_group"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ForwardingClasses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["forwarding_classes"] = val

		val, err = v.Queue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue"] = val

		val, err = v.QueueGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue_group"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ForwardingClassToQueueMappingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ForwardingClassToQueueMappingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ForwardingClassToQueueMappingValue) String() string {
	return "ForwardingClassToQueueMappingValue"
}

func (v ForwardingClassToQueueMappingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var forwardingClassesVal basetypes.ListValue
	switch {
	case v.ForwardingClasses.IsUnknown():
		forwardingClassesVal = types.ListUnknown(types.StringType)
	case v.ForwardingClasses.IsNull():
		forwardingClassesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		forwardingClassesVal, d = types.ListValue(types.StringType, v.ForwardingClasses.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"forwarding_classes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"queue":       basetypes.StringType{},
			"queue_group": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"queue":       basetypes.StringType{},
		"queue_group": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"forwarding_classes": forwardingClassesVal,
			"queue":              v.Queue,
			"queue_group":        v.QueueGroup,
		})

	return objVal, diags
}

func (v ForwardingClassToQueueMappingValue) Equal(o attr.Value) bool {
	other, ok := o.(ForwardingClassToQueueMappingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ForwardingClasses.Equal(other.ForwardingClasses) {
		return false
	}

	if !v.Queue.Equal(other.Queue) {
		return false
	}

	if !v.QueueGroup.Equal(other.QueueGroup) {
		return false
	}

	return true
}

func (v ForwardingClassToQueueMappingValue) Type(ctx context.Context) attr.Type {
	return ForwardingClassToQueueMappingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ForwardingClassToQueueMappingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"forwarding_classes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"queue":       basetypes.StringType{},
		"queue_group": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PfcDeadlockAvoidanceType{}

type PfcDeadlockAvoidanceType struct {
	basetypes.ObjectType
}

func (t PfcDeadlockAvoidanceType) Equal(o attr.Type) bool {
	other, ok := o.(PfcDeadlockAvoidanceType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PfcDeadlockAvoidanceType) String() string {
	return "PfcDeadlockAvoidanceType"
}

func (t PfcDeadlockAvoidanceType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deadlockAvoidanceAttribute, ok := attributes["deadlock_avoidance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_avoidance is missing from object`)

		return nil, diags
	}

	deadlockAvoidanceVal, ok := deadlockAvoidanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_avoidance expected to be basetypes.BoolValue, was: %T`, deadlockAvoidanceAttribute))
	}

	deadlockDetectionTimerAttribute, ok := attributes["deadlock_detection_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_detection_timer is missing from object`)

		return nil, diags
	}

	deadlockDetectionTimerVal, ok := deadlockDetectionTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_detection_timer expected to be basetypes.Int64Value, was: %T`, deadlockDetectionTimerAttribute))
	}

	deadlockRecoveryTimerAttribute, ok := attributes["deadlock_recovery_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_recovery_timer is missing from object`)

		return nil, diags
	}

	deadlockRecoveryTimerVal, ok := deadlockRecoveryTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_recovery_timer expected to be basetypes.Int64Value, was: %T`, deadlockRecoveryTimerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PfcDeadlockAvoidanceValue{
		DeadlockAvoidance:      deadlockAvoidanceVal,
		DeadlockDetectionTimer: deadlockDetectionTimerVal,
		DeadlockRecoveryTimer:  deadlockRecoveryTimerVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewPfcDeadlockAvoidanceValueNull() PfcDeadlockAvoidanceValue {
	return PfcDeadlockAvoidanceValue{
		state: attr.ValueStateNull,
	}
}

func NewPfcDeadlockAvoidanceValueUnknown() PfcDeadlockAvoidanceValue {
	return PfcDeadlockAvoidanceValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPfcDeadlockAvoidanceValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PfcDeadlockAvoidanceValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PfcDeadlockAvoidanceValue Attribute Value",
				"While creating a PfcDeadlockAvoidanceValue value, a missing attribute value was detected. "+
					"A PfcDeadlockAvoidanceValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PfcDeadlockAvoidanceValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PfcDeadlockAvoidanceValue Attribute Type",
				"While creating a PfcDeadlockAvoidanceValue value, an invalid attribute value was detected. "+
					"A PfcDeadlockAvoidanceValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PfcDeadlockAvoidanceValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PfcDeadlockAvoidanceValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PfcDeadlockAvoidanceValue Attribute Value",
				"While creating a PfcDeadlockAvoidanceValue value, an extra attribute value was detected. "+
					"A PfcDeadlockAvoidanceValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PfcDeadlockAvoidanceValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPfcDeadlockAvoidanceValueUnknown(), diags
	}

	deadlockAvoidanceAttribute, ok := attributes["deadlock_avoidance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_avoidance is missing from object`)

		return NewPfcDeadlockAvoidanceValueUnknown(), diags
	}

	deadlockAvoidanceVal, ok := deadlockAvoidanceAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_avoidance expected to be basetypes.BoolValue, was: %T`, deadlockAvoidanceAttribute))
	}

	deadlockDetectionTimerAttribute, ok := attributes["deadlock_detection_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_detection_timer is missing from object`)

		return NewPfcDeadlockAvoidanceValueUnknown(), diags
	}

	deadlockDetectionTimerVal, ok := deadlockDetectionTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_detection_timer expected to be basetypes.Int64Value, was: %T`, deadlockDetectionTimerAttribute))
	}

	deadlockRecoveryTimerAttribute, ok := attributes["deadlock_recovery_timer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deadlock_recovery_timer is missing from object`)

		return NewPfcDeadlockAvoidanceValueUnknown(), diags
	}

	deadlockRecoveryTimerVal, ok := deadlockRecoveryTimerAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deadlock_recovery_timer expected to be basetypes.Int64Value, was: %T`, deadlockRecoveryTimerAttribute))
	}

	if diags.HasError() {
		return NewPfcDeadlockAvoidanceValueUnknown(), diags
	}

	return PfcDeadlockAvoidanceValue{
		DeadlockAvoidance:      deadlockAvoidanceVal,
		DeadlockDetectionTimer: deadlockDetectionTimerVal,
		DeadlockRecoveryTimer:  deadlockRecoveryTimerVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewPfcDeadlockAvoidanceValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PfcDeadlockAvoidanceValue {
	object, diags := NewPfcDeadlockAvoidanceValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPfcDeadlockAvoidanceValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PfcDeadlockAvoidanceType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPfcDeadlockAvoidanceValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPfcDeadlockAvoidanceValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPfcDeadlockAvoidanceValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPfcDeadlockAvoidanceValueMust(PfcDeadlockAvoidanceValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PfcDeadlockAvoidanceType) ValueType(ctx context.Context) attr.Value {
	return PfcDeadlockAvoidanceValue{}
}

var _ basetypes.ObjectValuable = PfcDeadlockAvoidanceValue{}

type PfcDeadlockAvoidanceValue struct {
	DeadlockAvoidance      basetypes.BoolValue  `tfsdk:"deadlock_avoidance"`
	DeadlockDetectionTimer basetypes.Int64Value `tfsdk:"deadlock_detection_timer"`
	DeadlockRecoveryTimer  basetypes.Int64Value `tfsdk:"deadlock_recovery_timer"`
	state                  attr.ValueState
}

func (v PfcDeadlockAvoidanceValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["deadlock_avoidance"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["deadlock_detection_timer"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deadlock_recovery_timer"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.DeadlockAvoidance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deadlock_avoidance"] = val

		val, err = v.DeadlockDetectionTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deadlock_detection_timer"] = val

		val, err = v.DeadlockRecoveryTimer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deadlock_recovery_timer"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PfcDeadlockAvoidanceValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PfcDeadlockAvoidanceValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PfcDeadlockAvoidanceValue) String() string {
	return "PfcDeadlockAvoidanceValue"
}

func (v PfcDeadlockAvoidanceValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"deadlock_avoidance":       basetypes.BoolType{},
		"deadlock_detection_timer": basetypes.Int64Type{},
		"deadlock_recovery_timer":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"deadlock_avoidance":       v.DeadlockAvoidance,
			"deadlock_detection_timer": v.DeadlockDetectionTimer,
			"deadlock_recovery_timer":  v.DeadlockRecoveryTimer,
		})

	return objVal, diags
}

func (v PfcDeadlockAvoidanceValue) Equal(o attr.Value) bool {
	other, ok := o.(PfcDeadlockAvoidanceValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeadlockAvoidance.Equal(other.DeadlockAvoidance) {
		return false
	}

	if !v.DeadlockDetectionTimer.Equal(other.DeadlockDetectionTimer) {
		return false
	}

	if !v.DeadlockRecoveryTimer.Equal(other.DeadlockRecoveryTimer) {
		return false
	}

	return true
}

func (v PfcDeadlockAvoidanceValue) Type(ctx context.Context) attr.Type {
	return PfcDeadlockAvoidanceType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PfcDeadlockAvoidanceValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"deadlock_avoidance":       basetypes.BoolType{},
		"deadlock_detection_timer": basetypes.Int64Type{},
		"deadlock_recovery_timer":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = QueueManagementType{}

type QueueManagementType struct {
	basetypes.ObjectType
}

func (t QueueManagementType) Equal(o attr.Type) bool {
	other, ok := o.(QueueManagementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueueManagementType) String() string {
	return "QueueManagementType"
}

func (t QueueManagementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	queuesAttribute, ok := attributes["queues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queues is missing from object`)

		return nil, diags
	}

	queuesVal, ok := queuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queues expected to be basetypes.ListValue, was: %T`, queuesAttribute))
	}

	slopePolicyWeightAttribute, ok := attributes["slope_policy_weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slope_policy_weight is missing from object`)

		return nil, diags
	}

	slopePolicyWeightVal, ok := slopePolicyWeightAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slope_policy_weight expected to be basetypes.Int64Value, was: %T`, slopePolicyWeightAttribute))
	}

	wredSlopPoliciesAttribute, ok := attributes["wred_slop_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wred_slop_policies is missing from object`)

		return nil, diags
	}

	wredSlopPoliciesVal, ok := wredSlopPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wred_slop_policies expected to be basetypes.ListValue, was: %T`, wredSlopPoliciesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueueManagementValue{
		Queues:            queuesVal,
		SlopePolicyWeight: slopePolicyWeightVal,
		WredSlopPolicies:  wredSlopPoliciesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewQueueManagementValueNull() QueueManagementValue {
	return QueueManagementValue{
		state: attr.ValueStateNull,
	}
}

func NewQueueManagementValueUnknown() QueueManagementValue {
	return QueueManagementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueueManagementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueueManagementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueueManagementValue Attribute Value",
				"While creating a QueueManagementValue value, a missing attribute value was detected. "+
					"A QueueManagementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueueManagementValue Attribute Type",
				"While creating a QueueManagementValue value, an invalid attribute value was detected. "+
					"A QueueManagementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueueManagementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueueManagementValue Attribute Value",
				"While creating a QueueManagementValue value, an extra attribute value was detected. "+
					"A QueueManagementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueueManagementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueueManagementValueUnknown(), diags
	}

	queuesAttribute, ok := attributes["queues"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queues is missing from object`)

		return NewQueueManagementValueUnknown(), diags
	}

	queuesVal, ok := queuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queues expected to be basetypes.ListValue, was: %T`, queuesAttribute))
	}

	slopePolicyWeightAttribute, ok := attributes["slope_policy_weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slope_policy_weight is missing from object`)

		return NewQueueManagementValueUnknown(), diags
	}

	slopePolicyWeightVal, ok := slopePolicyWeightAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slope_policy_weight expected to be basetypes.Int64Value, was: %T`, slopePolicyWeightAttribute))
	}

	wredSlopPoliciesAttribute, ok := attributes["wred_slop_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wred_slop_policies is missing from object`)

		return NewQueueManagementValueUnknown(), diags
	}

	wredSlopPoliciesVal, ok := wredSlopPoliciesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wred_slop_policies expected to be basetypes.ListValue, was: %T`, wredSlopPoliciesAttribute))
	}

	if diags.HasError() {
		return NewQueueManagementValueUnknown(), diags
	}

	return QueueManagementValue{
		Queues:            queuesVal,
		SlopePolicyWeight: slopePolicyWeightVal,
		WredSlopPolicies:  wredSlopPoliciesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewQueueManagementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueueManagementValue {
	object, diags := NewQueueManagementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueueManagementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueueManagementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueueManagementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueueManagementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueueManagementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueueManagementValueMust(QueueManagementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueueManagementType) ValueType(ctx context.Context) attr.Value {
	return QueueManagementValue{}
}

var _ basetypes.ObjectValuable = QueueManagementValue{}

type QueueManagementValue struct {
	Queues            basetypes.ListValue  `tfsdk:"queues"`
	SlopePolicyWeight basetypes.Int64Value `tfsdk:"slope_policy_weight"`
	WredSlopPolicies  basetypes.ListValue  `tfsdk:"wred_slop_policies"`
	state             attr.ValueState
}

func (v QueueManagementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["queues"] = basetypes.ListType{
		ElemType: QueuesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["slope_policy_weight"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["wred_slop_policies"] = basetypes.ListType{
		ElemType: WredSlopPoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Queues.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queues"] = val

		val, err = v.SlopePolicyWeight.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slope_policy_weight"] = val

		val, err = v.WredSlopPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wred_slop_policies"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueueManagementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueueManagementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueueManagementValue) String() string {
	return "QueueManagementValue"
}

func (v QueueManagementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	queues := types.ListValueMust(
		QueuesType{
			basetypes.ObjectType{
				AttrTypes: QueuesValue{}.AttributeTypes(ctx),
			},
		},
		v.Queues.Elements(),
	)

	if v.Queues.IsNull() {
		queues = types.ListNull(
			QueuesType{
				basetypes.ObjectType{
					AttrTypes: QueuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Queues.IsUnknown() {
		queues = types.ListUnknown(
			QueuesType{
				basetypes.ObjectType{
					AttrTypes: QueuesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	wredSlopPolicies := types.ListValueMust(
		WredSlopPoliciesType{
			basetypes.ObjectType{
				AttrTypes: WredSlopPoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.WredSlopPolicies.Elements(),
	)

	if v.WredSlopPolicies.IsNull() {
		wredSlopPolicies = types.ListNull(
			WredSlopPoliciesType{
				basetypes.ObjectType{
					AttrTypes: WredSlopPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.WredSlopPolicies.IsUnknown() {
		wredSlopPolicies = types.ListUnknown(
			WredSlopPoliciesType{
				basetypes.ObjectType{
					AttrTypes: WredSlopPoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"queues": basetypes.ListType{
			ElemType: QueuesValue{}.Type(ctx),
		},
		"slope_policy_weight": basetypes.Int64Type{},
		"wred_slop_policies": basetypes.ListType{
			ElemType: WredSlopPoliciesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"queues":              queues,
			"slope_policy_weight": v.SlopePolicyWeight,
			"wred_slop_policies":  wredSlopPolicies,
		})

	return objVal, diags
}

func (v QueueManagementValue) Equal(o attr.Value) bool {
	other, ok := o.(QueueManagementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Queues.Equal(other.Queues) {
		return false
	}

	if !v.SlopePolicyWeight.Equal(other.SlopePolicyWeight) {
		return false
	}

	if !v.WredSlopPolicies.Equal(other.WredSlopPolicies) {
		return false
	}

	return true
}

func (v QueueManagementValue) Type(ctx context.Context) attr.Type {
	return QueueManagementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueueManagementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"queues": basetypes.ListType{
			ElemType: QueuesValue{}.Type(ctx),
		},
		"slope_policy_weight": basetypes.Int64Type{},
		"wred_slop_policies": basetypes.ListType{
			ElemType: WredSlopPoliciesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = QueuesType{}

type QueuesType struct {
	basetypes.ObjectType
}

func (t QueuesType) Equal(o attr.Type) bool {
	other, ok := o.(QueuesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QueuesType) String() string {
	return "QueuesType"
}

func (t QueuesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return nil, diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return nil, diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	pfcPauseFramePriorityAttribute, ok := attributes["pfc_pause_frame_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_pause_frame_priority is missing from object`)

		return nil, diags
	}

	pfcPauseFramePriorityVal, ok := pfcPauseFramePriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_pause_frame_priority expected to be basetypes.Int64Value, was: %T`, pfcPauseFramePriorityAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return nil, diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	schedulerPeakRatePercentAttribute, ok := attributes["scheduler_peak_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_peak_rate_percent is missing from object`)

		return nil, diags
	}

	schedulerPeakRatePercentVal, ok := schedulerPeakRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_peak_rate_percent expected to be basetypes.Int64Value, was: %T`, schedulerPeakRatePercentAttribute))
	}

	schedulerPriorityLevelAttribute, ok := attributes["scheduler_priority_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_priority_level is missing from object`)

		return nil, diags
	}

	schedulerPriorityLevelVal, ok := schedulerPriorityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_priority_level expected to be basetypes.Int64Value, was: %T`, schedulerPriorityLevelAttribute))
	}

	schedulerWeightAttribute, ok := attributes["scheduler_weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_weight is missing from object`)

		return nil, diags
	}

	schedulerWeightVal, ok := schedulerWeightAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_weight expected to be basetypes.Int64Value, was: %T`, schedulerWeightAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QueuesValue{
		CommittedBurstSize:       committedBurstSizeVal,
		MaximumBurstSize:         maximumBurstSizeVal,
		PfcPauseFramePriority:    pfcPauseFramePriorityVal,
		Queue:                    queueVal,
		SchedulerPeakRatePercent: schedulerPeakRatePercentVal,
		SchedulerPriorityLevel:   schedulerPriorityLevelVal,
		SchedulerWeight:          schedulerWeightVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewQueuesValueNull() QueuesValue {
	return QueuesValue{
		state: attr.ValueStateNull,
	}
}

func NewQueuesValueUnknown() QueuesValue {
	return QueuesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQueuesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QueuesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QueuesValue Attribute Value",
				"While creating a QueuesValue value, a missing attribute value was detected. "+
					"A QueuesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QueuesValue Attribute Type",
				"While creating a QueuesValue value, an invalid attribute value was detected. "+
					"A QueuesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QueuesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QueuesValue Attribute Value",
				"While creating a QueuesValue value, an extra attribute value was detected. "+
					"A QueuesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QueuesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQueuesValueUnknown(), diags
	}

	committedBurstSizeAttribute, ok := attributes["committed_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`committed_burst_size is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	committedBurstSizeVal, ok := committedBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`committed_burst_size expected to be basetypes.Int64Value, was: %T`, committedBurstSizeAttribute))
	}

	maximumBurstSizeAttribute, ok := attributes["maximum_burst_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximum_burst_size is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	maximumBurstSizeVal, ok := maximumBurstSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximum_burst_size expected to be basetypes.Int64Value, was: %T`, maximumBurstSizeAttribute))
	}

	pfcPauseFramePriorityAttribute, ok := attributes["pfc_pause_frame_priority"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pfc_pause_frame_priority is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	pfcPauseFramePriorityVal, ok := pfcPauseFramePriorityAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pfc_pause_frame_priority expected to be basetypes.Int64Value, was: %T`, pfcPauseFramePriorityAttribute))
	}

	queueAttribute, ok := attributes["queue"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`queue is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	queueVal, ok := queueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`queue expected to be basetypes.StringValue, was: %T`, queueAttribute))
	}

	schedulerPeakRatePercentAttribute, ok := attributes["scheduler_peak_rate_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_peak_rate_percent is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	schedulerPeakRatePercentVal, ok := schedulerPeakRatePercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_peak_rate_percent expected to be basetypes.Int64Value, was: %T`, schedulerPeakRatePercentAttribute))
	}

	schedulerPriorityLevelAttribute, ok := attributes["scheduler_priority_level"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_priority_level is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	schedulerPriorityLevelVal, ok := schedulerPriorityLevelAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_priority_level expected to be basetypes.Int64Value, was: %T`, schedulerPriorityLevelAttribute))
	}

	schedulerWeightAttribute, ok := attributes["scheduler_weight"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scheduler_weight is missing from object`)

		return NewQueuesValueUnknown(), diags
	}

	schedulerWeightVal, ok := schedulerWeightAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scheduler_weight expected to be basetypes.Int64Value, was: %T`, schedulerWeightAttribute))
	}

	if diags.HasError() {
		return NewQueuesValueUnknown(), diags
	}

	return QueuesValue{
		CommittedBurstSize:       committedBurstSizeVal,
		MaximumBurstSize:         maximumBurstSizeVal,
		PfcPauseFramePriority:    pfcPauseFramePriorityVal,
		Queue:                    queueVal,
		SchedulerPeakRatePercent: schedulerPeakRatePercentVal,
		SchedulerPriorityLevel:   schedulerPriorityLevelVal,
		SchedulerWeight:          schedulerWeightVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewQueuesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QueuesValue {
	object, diags := NewQueuesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQueuesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QueuesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQueuesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQueuesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQueuesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQueuesValueMust(QueuesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QueuesType) ValueType(ctx context.Context) attr.Value {
	return QueuesValue{}
}

var _ basetypes.ObjectValuable = QueuesValue{}

type QueuesValue struct {
	CommittedBurstSize       basetypes.Int64Value  `tfsdk:"committed_burst_size"`
	MaximumBurstSize         basetypes.Int64Value  `tfsdk:"maximum_burst_size"`
	PfcPauseFramePriority    basetypes.Int64Value  `tfsdk:"pfc_pause_frame_priority"`
	Queue                    basetypes.StringValue `tfsdk:"queue"`
	SchedulerPeakRatePercent basetypes.Int64Value  `tfsdk:"scheduler_peak_rate_percent"`
	SchedulerPriorityLevel   basetypes.Int64Value  `tfsdk:"scheduler_priority_level"`
	SchedulerWeight          basetypes.Int64Value  `tfsdk:"scheduler_weight"`
	state                    attr.ValueState
}

func (v QueuesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["committed_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["maximum_burst_size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["pfc_pause_frame_priority"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["queue"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scheduler_peak_rate_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scheduler_priority_level"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["scheduler_weight"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CommittedBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["committed_burst_size"] = val

		val, err = v.MaximumBurstSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maximum_burst_size"] = val

		val, err = v.PfcPauseFramePriority.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pfc_pause_frame_priority"] = val

		val, err = v.Queue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["queue"] = val

		val, err = v.SchedulerPeakRatePercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scheduler_peak_rate_percent"] = val

		val, err = v.SchedulerPriorityLevel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scheduler_priority_level"] = val

		val, err = v.SchedulerWeight.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scheduler_weight"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QueuesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QueuesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QueuesValue) String() string {
	return "QueuesValue"
}

func (v QueuesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"committed_burst_size":        basetypes.Int64Type{},
		"maximum_burst_size":          basetypes.Int64Type{},
		"pfc_pause_frame_priority":    basetypes.Int64Type{},
		"queue":                       basetypes.StringType{},
		"scheduler_peak_rate_percent": basetypes.Int64Type{},
		"scheduler_priority_level":    basetypes.Int64Type{},
		"scheduler_weight":            basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"committed_burst_size":        v.CommittedBurstSize,
			"maximum_burst_size":          v.MaximumBurstSize,
			"pfc_pause_frame_priority":    v.PfcPauseFramePriority,
			"queue":                       v.Queue,
			"scheduler_peak_rate_percent": v.SchedulerPeakRatePercent,
			"scheduler_priority_level":    v.SchedulerPriorityLevel,
			"scheduler_weight":            v.SchedulerWeight,
		})

	return objVal, diags
}

func (v QueuesValue) Equal(o attr.Value) bool {
	other, ok := o.(QueuesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CommittedBurstSize.Equal(other.CommittedBurstSize) {
		return false
	}

	if !v.MaximumBurstSize.Equal(other.MaximumBurstSize) {
		return false
	}

	if !v.PfcPauseFramePriority.Equal(other.PfcPauseFramePriority) {
		return false
	}

	if !v.Queue.Equal(other.Queue) {
		return false
	}

	if !v.SchedulerPeakRatePercent.Equal(other.SchedulerPeakRatePercent) {
		return false
	}

	if !v.SchedulerPriorityLevel.Equal(other.SchedulerPriorityLevel) {
		return false
	}

	if !v.SchedulerWeight.Equal(other.SchedulerWeight) {
		return false
	}

	return true
}

func (v QueuesValue) Type(ctx context.Context) attr.Type {
	return QueuesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QueuesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"committed_burst_size":        basetypes.Int64Type{},
		"maximum_burst_size":          basetypes.Int64Type{},
		"pfc_pause_frame_priority":    basetypes.Int64Type{},
		"queue":                       basetypes.StringType{},
		"scheduler_peak_rate_percent": basetypes.Int64Type{},
		"scheduler_priority_level":    basetypes.Int64Type{},
		"scheduler_weight":            basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = WredSlopPoliciesType{}

type WredSlopPoliciesType struct {
	basetypes.ObjectType
}

func (t WredSlopPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(WredSlopPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WredSlopPoliciesType) String() string {
	return "WredSlopPoliciesType"
}

func (t WredSlopPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dropAttribute, ok := attributes["drop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop is missing from object`)

		return nil, diags
	}

	dropVal, ok := dropAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop expected to be basetypes.BoolValue, was: %T`, dropAttribute))
	}

	dropProbabilityAttribute, ok := attributes["drop_probability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability is missing from object`)

		return nil, diags
	}

	dropProbabilityVal, ok := dropProbabilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability expected to be basetypes.StringValue, was: %T`, dropProbabilityAttribute))
	}

	ecnAttribute, ok := attributes["ecn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn is missing from object`)

		return nil, diags
	}

	ecnVal, ok := ecnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn expected to be basetypes.BoolValue, was: %T`, ecnAttribute))
	}

	maxDropProbabilityPercentAttribute, ok := attributes["max_drop_probability_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_drop_probability_percent is missing from object`)

		return nil, diags
	}

	maxDropProbabilityPercentVal, ok := maxDropProbabilityPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_drop_probability_percent expected to be basetypes.Int64Value, was: %T`, maxDropProbabilityPercentAttribute))
	}

	maxThresholdAttribute, ok := attributes["max_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_threshold is missing from object`)

		return nil, diags
	}

	maxThresholdVal, ok := maxThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_threshold expected to be basetypes.Int64Value, was: %T`, maxThresholdAttribute))
	}

	maxThresholdPercentAttribute, ok := attributes["max_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_threshold_percent is missing from object`)

		return nil, diags
	}

	maxThresholdPercentVal, ok := maxThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_threshold_percent expected to be basetypes.Int64Value, was: %T`, maxThresholdPercentAttribute))
	}

	minThresholdAttribute, ok := attributes["min_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_threshold is missing from object`)

		return nil, diags
	}

	minThresholdVal, ok := minThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_threshold expected to be basetypes.Int64Value, was: %T`, minThresholdAttribute))
	}

	minThresholdPercentAttribute, ok := attributes["min_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_threshold_percent is missing from object`)

		return nil, diags
	}

	minThresholdPercentVal, ok := minThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_threshold_percent expected to be basetypes.Int64Value, was: %T`, minThresholdPercentAttribute))
	}

	trafficTypeAttribute, ok := attributes["traffic_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_type is missing from object`)

		return nil, diags
	}

	trafficTypeVal, ok := trafficTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_type expected to be basetypes.StringValue, was: %T`, trafficTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WredSlopPoliciesValue{
		Drop:                      dropVal,
		DropProbability:           dropProbabilityVal,
		Ecn:                       ecnVal,
		MaxDropProbabilityPercent: maxDropProbabilityPercentVal,
		MaxThreshold:              maxThresholdVal,
		MaxThresholdPercent:       maxThresholdPercentVal,
		MinThreshold:              minThresholdVal,
		MinThresholdPercent:       minThresholdPercentVal,
		TrafficType:               trafficTypeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWredSlopPoliciesValueNull() WredSlopPoliciesValue {
	return WredSlopPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewWredSlopPoliciesValueUnknown() WredSlopPoliciesValue {
	return WredSlopPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWredSlopPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WredSlopPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WredSlopPoliciesValue Attribute Value",
				"While creating a WredSlopPoliciesValue value, a missing attribute value was detected. "+
					"A WredSlopPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WredSlopPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WredSlopPoliciesValue Attribute Type",
				"While creating a WredSlopPoliciesValue value, an invalid attribute value was detected. "+
					"A WredSlopPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WredSlopPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WredSlopPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WredSlopPoliciesValue Attribute Value",
				"While creating a WredSlopPoliciesValue value, an extra attribute value was detected. "+
					"A WredSlopPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WredSlopPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWredSlopPoliciesValueUnknown(), diags
	}

	dropAttribute, ok := attributes["drop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	dropVal, ok := dropAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop expected to be basetypes.BoolValue, was: %T`, dropAttribute))
	}

	dropProbabilityAttribute, ok := attributes["drop_probability"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`drop_probability is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	dropProbabilityVal, ok := dropProbabilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`drop_probability expected to be basetypes.StringValue, was: %T`, dropProbabilityAttribute))
	}

	ecnAttribute, ok := attributes["ecn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecn is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	ecnVal, ok := ecnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecn expected to be basetypes.BoolValue, was: %T`, ecnAttribute))
	}

	maxDropProbabilityPercentAttribute, ok := attributes["max_drop_probability_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_drop_probability_percent is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	maxDropProbabilityPercentVal, ok := maxDropProbabilityPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_drop_probability_percent expected to be basetypes.Int64Value, was: %T`, maxDropProbabilityPercentAttribute))
	}

	maxThresholdAttribute, ok := attributes["max_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_threshold is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	maxThresholdVal, ok := maxThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_threshold expected to be basetypes.Int64Value, was: %T`, maxThresholdAttribute))
	}

	maxThresholdPercentAttribute, ok := attributes["max_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_threshold_percent is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	maxThresholdPercentVal, ok := maxThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_threshold_percent expected to be basetypes.Int64Value, was: %T`, maxThresholdPercentAttribute))
	}

	minThresholdAttribute, ok := attributes["min_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_threshold is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	minThresholdVal, ok := minThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_threshold expected to be basetypes.Int64Value, was: %T`, minThresholdAttribute))
	}

	minThresholdPercentAttribute, ok := attributes["min_threshold_percent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_threshold_percent is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	minThresholdPercentVal, ok := minThresholdPercentAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_threshold_percent expected to be basetypes.Int64Value, was: %T`, minThresholdPercentAttribute))
	}

	trafficTypeAttribute, ok := attributes["traffic_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`traffic_type is missing from object`)

		return NewWredSlopPoliciesValueUnknown(), diags
	}

	trafficTypeVal, ok := trafficTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`traffic_type expected to be basetypes.StringValue, was: %T`, trafficTypeAttribute))
	}

	if diags.HasError() {
		return NewWredSlopPoliciesValueUnknown(), diags
	}

	return WredSlopPoliciesValue{
		Drop:                      dropVal,
		DropProbability:           dropProbabilityVal,
		Ecn:                       ecnVal,
		MaxDropProbabilityPercent: maxDropProbabilityPercentVal,
		MaxThreshold:              maxThresholdVal,
		MaxThresholdPercent:       maxThresholdPercentVal,
		MinThreshold:              minThresholdVal,
		MinThresholdPercent:       minThresholdPercentVal,
		TrafficType:               trafficTypeVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewWredSlopPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WredSlopPoliciesValue {
	object, diags := NewWredSlopPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWredSlopPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WredSlopPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWredSlopPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWredSlopPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWredSlopPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWredSlopPoliciesValueMust(WredSlopPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WredSlopPoliciesType) ValueType(ctx context.Context) attr.Value {
	return WredSlopPoliciesValue{}
}

var _ basetypes.ObjectValuable = WredSlopPoliciesValue{}

type WredSlopPoliciesValue struct {
	Drop                      basetypes.BoolValue   `tfsdk:"drop"`
	DropProbability           basetypes.StringValue `tfsdk:"drop_probability"`
	Ecn                       basetypes.BoolValue   `tfsdk:"ecn"`
	MaxDropProbabilityPercent basetypes.Int64Value  `tfsdk:"max_drop_probability_percent"`
	MaxThreshold              basetypes.Int64Value  `tfsdk:"max_threshold"`
	MaxThresholdPercent       basetypes.Int64Value  `tfsdk:"max_threshold_percent"`
	MinThreshold              basetypes.Int64Value  `tfsdk:"min_threshold"`
	MinThresholdPercent       basetypes.Int64Value  `tfsdk:"min_threshold_percent"`
	TrafficType               basetypes.StringValue `tfsdk:"traffic_type"`
	state                     attr.ValueState
}

func (v WredSlopPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["drop"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["drop_probability"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecn"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_drop_probability_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_threshold_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_threshold_percent"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["traffic_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.Drop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop"] = val

		val, err = v.DropProbability.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["drop_probability"] = val

		val, err = v.Ecn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecn"] = val

		val, err = v.MaxDropProbabilityPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_drop_probability_percent"] = val

		val, err = v.MaxThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_threshold"] = val

		val, err = v.MaxThresholdPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_threshold_percent"] = val

		val, err = v.MinThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_threshold"] = val

		val, err = v.MinThresholdPercent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_threshold_percent"] = val

		val, err = v.TrafficType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["traffic_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WredSlopPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WredSlopPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WredSlopPoliciesValue) String() string {
	return "WredSlopPoliciesValue"
}

func (v WredSlopPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"drop":                         basetypes.BoolType{},
		"drop_probability":             basetypes.StringType{},
		"ecn":                          basetypes.BoolType{},
		"max_drop_probability_percent": basetypes.Int64Type{},
		"max_threshold":                basetypes.Int64Type{},
		"max_threshold_percent":        basetypes.Int64Type{},
		"min_threshold":                basetypes.Int64Type{},
		"min_threshold_percent":        basetypes.Int64Type{},
		"traffic_type":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"drop":                         v.Drop,
			"drop_probability":             v.DropProbability,
			"ecn":                          v.Ecn,
			"max_drop_probability_percent": v.MaxDropProbabilityPercent,
			"max_threshold":                v.MaxThreshold,
			"max_threshold_percent":        v.MaxThresholdPercent,
			"min_threshold":                v.MinThreshold,
			"min_threshold_percent":        v.MinThresholdPercent,
			"traffic_type":                 v.TrafficType,
		})

	return objVal, diags
}

func (v WredSlopPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(WredSlopPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Drop.Equal(other.Drop) {
		return false
	}

	if !v.DropProbability.Equal(other.DropProbability) {
		return false
	}

	if !v.Ecn.Equal(other.Ecn) {
		return false
	}

	if !v.MaxDropProbabilityPercent.Equal(other.MaxDropProbabilityPercent) {
		return false
	}

	if !v.MaxThreshold.Equal(other.MaxThreshold) {
		return false
	}

	if !v.MaxThresholdPercent.Equal(other.MaxThresholdPercent) {
		return false
	}

	if !v.MinThreshold.Equal(other.MinThreshold) {
		return false
	}

	if !v.MinThresholdPercent.Equal(other.MinThresholdPercent) {
		return false
	}

	if !v.TrafficType.Equal(other.TrafficType) {
		return false
	}

	return true
}

func (v WredSlopPoliciesValue) Type(ctx context.Context) attr.Type {
	return WredSlopPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WredSlopPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"drop":                         basetypes.BoolType{},
		"drop_probability":             basetypes.StringType{},
		"ecn":                          basetypes.BoolType{},
		"max_drop_probability_percent": basetypes.Int64Type{},
		"max_threshold":                basetypes.Int64Type{},
		"max_threshold_percent":        basetypes.Int64Type{},
		"min_threshold":                basetypes.Int64Type{},
		"min_threshold_percent":        basetypes.Int64Type{},
		"traffic_type":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		state: attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	state attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 0)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 0)

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{}
}
